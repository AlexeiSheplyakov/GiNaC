\input texinfo  @c -*-texinfo-*-
@c %**start of header
@setfilename ginac.info
@settitle GiNaC, an open framework for symbolic computation within the C++ programming language
@setchapternewpage on
@afourpaper
@c For `info' only.
@paragraphindent 0
@c For TeX only.
@iftex
@c I hate putting "@noindent" in front of every paragraph.
@parindent=0pt
@end iftex
@c %**end of header

@include version.texi

@direntry
* ginac: (ginac).                   C++ library for symbolic computation.
@end direntry

@ifinfo
This is a tutorial that documents GiNaC @value{VERSION}, an open
framework for symbolic computation within the C++ programming language.

Copyright (C) 1999-2004 Johannes Gutenberg University Mainz, Germany

Permission is granted to make and distribute verbatim copies of
this manual provided the copyright notice and this permission notice
are preserved on all copies.

@ignore
Permission is granted to process this file through TeX and print the
results, provided the printed document carries copying permission
notice identical to this one except for the removal of this paragraph

@end ignore
Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided that the entire
resulting derived work is distributed under the terms of a permission
notice identical to this one.
@end ifinfo

@finalout
@c finalout prevents ugly black rectangles on overfull hbox lines
@titlepage
@title GiNaC @value{VERSION}
@subtitle An open framework for symbolic computation within the C++ programming language
@subtitle @value{UPDATED}
@author The GiNaC Group:
@author Christian Bauer, Alexander Frink, Richard Kreckel, Jens Vollinga

@page
@vskip 0pt plus 1filll
Copyright @copyright{} 1999-2004 Johannes Gutenberg University Mainz, Germany
@sp 2
Permission is granted to make and distribute verbatim copies of
this manual provided the copyright notice and this permission notice
are preserved on all copies.

Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided that the entire
resulting derived work is distributed under the terms of a permission
notice identical to this one.
@end titlepage

@page
@contents

@page


@node Top, Introduction, (dir), (dir)
@c    node-name, next, previous, up
@top GiNaC

This is a tutorial that documents GiNaC @value{VERSION}, an open
framework for symbolic computation within the C++ programming language.

@menu
* Introduction::                 GiNaC's purpose.
* A Tour of GiNaC::              A quick tour of the library.
* Installation::                 How to install the package.
* Basic Concepts::               Description of fundamental classes.
* Methods and Functions::        Algorithms for symbolic manipulations.
* Extending GiNaC::              How to extend the library.
* A Comparison With Other CAS::  Compares GiNaC to traditional CAS.
* Internal Structures::          Description of some internal structures.
* Package Tools::                Configuring packages to work with GiNaC.
* Bibliography::
* Concept Index::
@end menu


@node Introduction, A Tour of GiNaC, Top, Top
@c    node-name, next, previous, up
@chapter Introduction
@cindex history of GiNaC

The motivation behind GiNaC derives from the observation that most
present day computer algebra systems (CAS) are linguistically and
semantically impoverished.  Although they are quite powerful tools for
learning math and solving particular problems they lack modern
linguistic structures that allow for the creation of large-scale
projects.  GiNaC is an attempt to overcome this situation by extending a
well established and standardized computer language (C++) by some
fundamental symbolic capabilities, thus allowing for integrated systems
that embed symbolic manipulations together with more established areas
of computer science (like computation-intense numeric applications,
graphical interfaces, etc.) under one roof.

The particular problem that led to the writing of the GiNaC framework is
still a very active field of research, namely the calculation of higher
order corrections to elementary particle interactions.  There,
theoretical physicists are interested in matching present day theories
against experiments taking place at particle accelerators.  The
computations involved are so complex they call for a combined symbolical
and numerical approach.  This turned out to be quite difficult to
accomplish with the present day CAS we have worked with so far and so we
tried to fill the gap by writing GiNaC.  But of course its applications
are in no way restricted to theoretical physics.

This tutorial is intended for the novice user who is new to GiNaC but
already has some background in C++ programming.  However, since a
hand-made documentation like this one is difficult to keep in sync with
the development, the actual documentation is inside the sources in the
form of comments.  That documentation may be parsed by one of the many
Javadoc-like documentation systems.  If you fail at generating it you
may access it from @uref{http://www.ginac.de/reference/, the GiNaC home
page}.  It is an invaluable resource not only for the advanced user who
wishes to extend the system (or chase bugs) but for everybody who wants
to comprehend the inner workings of GiNaC.  This little tutorial on the
other hand only covers the basic things that are unlikely to change in
the near future.

@section License
The GiNaC framework for symbolic computation within the C++ programming
language is Copyright @copyright{} 1999-2004 Johannes Gutenberg
University Mainz, Germany.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License as
published by the Free Software Foundation; either version 2 of the
License, or (at your option) any later version.

This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; see the file COPYING.  If not, write to the
Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,
MA 02111-1307, USA.


@node A Tour of GiNaC, How to use it from within C++, Introduction, Top
@c    node-name, next, previous, up
@chapter A Tour of GiNaC

This quick tour of GiNaC wants to arise your interest in the
subsequent chapters by showing off a bit.  Please excuse us if it
leaves many open questions.

@menu
* How to use it from within C++::  Two simple examples.
* What it can do for you::         A Tour of GiNaC's features.
@end menu


@node How to use it from within C++, What it can do for you, A Tour of GiNaC, A Tour of GiNaC
@c    node-name, next, previous, up
@section How to use it from within C++

The GiNaC open framework for symbolic computation within the C++ programming
language does not try to define a language of its own as conventional
CAS do.  Instead, it extends the capabilities of C++ by symbolic
manipulations.  Here is how to generate and print a simple (and rather
pointless) bivariate polynomial with some large coefficients:

@example
#include <iostream>
#include <ginac/ginac.h>
using namespace std;
using namespace GiNaC;

int main()
@{
    symbol x("x"), y("y");
    ex poly;

    for (int i=0; i<3; ++i)
        poly += factorial(i+16)*pow(x,i)*pow(y,2-i);

    cout << poly << endl;
    return 0;
@}
@end example

Assuming the file is called @file{hello.cc}, on our system we can compile
and run it like this:

@example
$ c++ hello.cc -o hello -lcln -lginac
$ ./hello
355687428096000*x*y+20922789888000*y^2+6402373705728000*x^2
@end example

(@xref{Package Tools}, for tools that help you when creating a software
package that uses GiNaC.)

@cindex Hermite polynomial
Next, there is a more meaningful C++ program that calls a function which
generates Hermite polynomials in a specified free variable.

@example
#include <iostream>
#include <ginac/ginac.h>
using namespace std;
using namespace GiNaC;

ex HermitePoly(const symbol & x, int n)
@{
    ex HKer=exp(-pow(x, 2));
    // uses the identity H_n(x) == (-1)^n exp(x^2) (d/dx)^n exp(-x^2)
    return normal(pow(-1, n) * diff(HKer, x, n) / HKer);
@}

int main()
@{
    symbol z("z");

    for (int i=0; i<6; ++i)
        cout << "H_" << i << "(z) == " << HermitePoly(z,i) << endl;

    return 0;
@}
@end example

When run, this will type out

@example
H_0(z) == 1
H_1(z) == 2*z
H_2(z) == 4*z^2-2
H_3(z) == -12*z+8*z^3
H_4(z) == -48*z^2+16*z^4+12
H_5(z) == 120*z-160*z^3+32*z^5
@end example

This method of generating the coefficients is of course far from optimal
for production purposes.

In order to show some more examples of what GiNaC can do we will now use
the @command{ginsh}, a simple GiNaC interactive shell that provides a
convenient window into GiNaC's capabilities.


@node What it can do for you, Installation, How to use it from within C++, A Tour of GiNaC
@c    node-name, next, previous, up
@section What it can do for you

@cindex @command{ginsh}
After invoking @command{ginsh} one can test and experiment with GiNaC's
features much like in other Computer Algebra Systems except that it does
not provide programming constructs like loops or conditionals.  For a
concise description of the @command{ginsh} syntax we refer to its
accompanied man page. Suffice to say that assignments and comparisons in
@command{ginsh} are written as they are in C, i.e. @code{=} assigns and
@code{==} compares.

It can manipulate arbitrary precision integers in a very fast way.
Rational numbers are automatically converted to fractions of coprime
integers:

@example
> x=3^150;
369988485035126972924700782451696644186473100389722973815184405301748249
> y=3^149;
123329495011708990974900260817232214728824366796574324605061468433916083
> x/y;
3
> y/x;
1/3
@end example

Exact numbers are always retained as exact numbers and only evaluated as
floating point numbers if requested.  For instance, with numeric
radicals is dealt pretty much as with symbols.  Products of sums of them
can be expanded:

@example
> expand((1+a^(1/5)-a^(2/5))^3);
1+3*a+3*a^(1/5)-5*a^(3/5)-a^(6/5)
> expand((1+3^(1/5)-3^(2/5))^3);
10-5*3^(3/5)
> evalf((1+3^(1/5)-3^(2/5))^3);
0.33408977534118624228
@end example

The function @code{evalf} that was used above converts any number in
GiNaC's expressions into floating point numbers.  This can be done to
arbitrary predefined accuracy:

@example
> evalf(1/7);
0.14285714285714285714
> Digits=150;
150
> evalf(1/7);
0.1428571428571428571428571428571428571428571428571428571428571428571428
5714285714285714285714285714285714285
@end example

Exact numbers other than rationals that can be manipulated in GiNaC
include predefined constants like Archimedes' @code{Pi}.  They can both
be used in symbolic manipulations (as an exact number) as well as in
numeric expressions (as an inexact number):

@example
> a=Pi^2+x;
x+Pi^2
> evalf(a);
9.869604401089358619+x
> x=2;
2
> evalf(a);
11.869604401089358619
@end example

Built-in functions evaluate immediately to exact numbers if
this is possible.  Conversions that can be safely performed are done
immediately; conversions that are not generally valid are not done:

@example
> cos(42*Pi);
1
> cos(acos(x));
x
> acos(cos(x));
acos(cos(x))
@end example

(Note that converting the last input to @code{x} would allow one to
conclude that @code{42*Pi} is equal to @code{0}.)

Linear equation systems can be solved along with basic linear
algebra manipulations over symbolic expressions.  In C++ GiNaC offers
a matrix class for this purpose but we can see what it can do using
@command{ginsh}'s bracket notation to type them in:

@example
> lsolve(a+x*y==z,x);
y^(-1)*(z-a);
> lsolve(@{3*x+5*y == 7, -2*x+10*y == -5@}, @{x, y@});
@{x==19/8,y==-1/40@}
> M = [ [1, 3], [-3, 2] ];
[[1,3],[-3,2]]
> determinant(M);
11
> charpoly(M,lambda);
lambda^2-3*lambda+11
> A = [ [1, 1], [2, -1] ];
[[1,1],[2,-1]]
> A+2*M;
[[1,1],[2,-1]]+2*[[1,3],[-3,2]]
> evalm(%);
[[3,7],[-4,3]]
> B = [ [0, 0, a], [b, 1, -b], [-1/a, 0, 0] ];
> evalm(B^(2^12345));
[[1,0,0],[0,1,0],[0,0,1]]
@end example

Multivariate polynomials and rational functions may be expanded,
collected and normalized (i.e. converted to a ratio of two coprime 
polynomials):

@example
> a = x^4 + 2*x^2*y^2 + 4*x^3*y + 12*x*y^3 - 3*y^4;
12*x*y^3+2*x^2*y^2+4*x^3*y-3*y^4+x^4
> b = x^2 + 4*x*y - y^2;
4*x*y-y^2+x^2
> expand(a*b);
8*x^5*y+17*x^4*y^2+43*x^2*y^4-24*x*y^5+16*x^3*y^3+3*y^6+x^6
> collect(a+b,x);
4*x^3*y-y^2-3*y^4+(12*y^3+4*y)*x+x^4+x^2*(1+2*y^2)
> collect(a+b,y);
12*x*y^3-3*y^4+(-1+2*x^2)*y^2+(4*x+4*x^3)*y+x^2+x^4
> normal(a/b);
3*y^2+x^2
@end example

You can differentiate functions and expand them as Taylor or Laurent
series in a very natural syntax (the second argument of @code{series} is
a relation defining the evaluation point, the third specifies the
order):

@cindex Zeta function
@example
> diff(tan(x),x);
tan(x)^2+1
> series(sin(x),x==0,4);
x-1/6*x^3+Order(x^4)
> series(1/tan(x),x==0,4);
x^(-1)-1/3*x+Order(x^2)
> series(tgamma(x),x==0,3);
x^(-1)-Euler+(1/12*Pi^2+1/2*Euler^2)*x+
(-1/3*zeta(3)-1/12*Pi^2*Euler-1/6*Euler^3)*x^2+Order(x^3)
> evalf(%);
x^(-1)-0.5772156649015328606+(0.9890559953279725555)*x
-(0.90747907608088628905)*x^2+Order(x^3)
> series(tgamma(2*sin(x)-2),x==Pi/2,6);
-(x-1/2*Pi)^(-2)+(-1/12*Pi^2-1/2*Euler^2-1/240)*(x-1/2*Pi)^2
-Euler-1/12+Order((x-1/2*Pi)^3)
@end example

Here we have made use of the @command{ginsh}-command @code{%} to pop the
previously evaluated element from @command{ginsh}'s internal stack.

If you ever wanted to convert units in C or C++ and found this is
cumbersome, here is the solution.  Symbolic types can always be used as
tags for different types of objects.  Converting from wrong units to the
metric system is now easy:

@example
> in=.0254*m;
0.0254*m
> lb=.45359237*kg;
0.45359237*kg
> 200*lb/in^2;
140613.91592783185568*kg*m^(-2)
@end example


@node Installation, Prerequisites, What it can do for you, Top
@c    node-name, next, previous, up
@chapter Installation

@cindex CLN
GiNaC's installation follows the spirit of most GNU software. It is
easily installed on your system by three steps: configuration, build,
installation.

@menu
* Prerequisites::                Packages upon which GiNaC depends.
* Configuration::                How to configure GiNaC.
* Building GiNaC::               How to compile GiNaC.
* Installing GiNaC::             How to install GiNaC on your system.
@end menu


@node Prerequisites, Configuration, Installation, Installation
@c    node-name, next, previous, up
@section Prerequisites

In order to install GiNaC on your system, some prerequisites need to be
met.  First of all, you need to have a C++-compiler adhering to the
ANSI-standard @cite{ISO/IEC 14882:1998(E)}.  We used GCC for development
so if you have a different compiler you are on your own.  For the
configuration to succeed you need a Posix compliant shell installed in
@file{/bin/sh}, GNU @command{bash} is fine.  Perl is needed by the built
process as well, since some of the source files are automatically
generated by Perl scripts.  Last but not least, Bruno Haible's library
CLN is extensively used and needs to be installed on your system.
Please get it either from @uref{ftp://ftp.santafe.edu/pub/gnu/}, from
@uref{ftp://ftpthep.physik.uni-mainz.de/pub/gnu/, GiNaC's FTP site} or
from @uref{ftp://ftp.ilog.fr/pub/Users/haible/gnu/, Bruno Haible's FTP
site} (it is covered by GPL) and install it prior to trying to install
GiNaC.  The configure script checks if it can find it and if it cannot
it will refuse to continue.


@node Configuration, Building GiNaC, Prerequisites, Installation
@c    node-name, next, previous, up
@section Configuration
@cindex configuration
@cindex Autoconf

To configure GiNaC means to prepare the source distribution for
building.  It is done via a shell script called @command{configure} that
is shipped with the sources and was originally generated by GNU
Autoconf.  Since a configure script generated by GNU Autoconf never
prompts, all customization must be done either via command line
parameters or environment variables.  It accepts a list of parameters,
the complete set of which can be listed by calling it with the
@option{--help} option.  The most important ones will be shortly
described in what follows:

@itemize @bullet

@item
@option{--disable-shared}: When given, this option switches off the
build of a shared library, i.e. a @file{.so} file.  This may be convenient
when developing because it considerably speeds up compilation.

@item
@option{--prefix=@var{PREFIX}}: The directory where the compiled library
and headers are installed. It defaults to @file{/usr/local} which means
that the library is installed in the directory @file{/usr/local/lib},
the header files in @file{/usr/local/include/ginac} and the documentation
(like this one) into @file{/usr/local/share/doc/GiNaC}.

@item
@option{--libdir=@var{LIBDIR}}: Use this option in case you want to have
the library installed in some other directory than
@file{@var{PREFIX}/lib/}.

@item
@option{--includedir=@var{INCLUDEDIR}}: Use this option in case you want
to have the header files installed in some other directory than
@file{@var{PREFIX}/include/ginac/}. For instance, if you specify
@option{--includedir=/usr/include} you will end up with the header files
sitting in the directory @file{/usr/include/ginac/}. Note that the
subdirectory @file{ginac} is enforced by this process in order to
keep the header files separated from others.  This avoids some
clashes and allows for an easier deinstallation of GiNaC. This ought
to be considered A Good Thing (tm).

@item
@option{--datadir=@var{DATADIR}}: This option may be given in case you
want to have the documentation installed in some other directory than
@file{@var{PREFIX}/share/doc/GiNaC/}.

@end itemize

In addition, you may specify some environment variables.  @env{CXX}
holds the path and the name of the C++ compiler in case you want to
override the default in your path.  (The @command{configure} script
searches your path for @command{c++}, @command{g++}, @command{gcc},
@command{CC}, @command{cxx} and @command{cc++} in that order.)  It may
be very useful to define some compiler flags with the @env{CXXFLAGS}
environment variable, like optimization, debugging information and
warning levels.  If omitted, it defaults to @option{-g
-O2}.@footnote{The @command{configure} script is itself generated from
the file @file{configure.ac}.  It is only distributed in packaged
releases of GiNaC.  If you got the naked sources, e.g. from CVS, you
must generate @command{configure} along with the various
@file{Makefile.in} by using the @command{autogen.sh} script.  This will
require a fair amount of support from your local toolchain, though.}

The whole process is illustrated in the following two
examples. (Substitute @command{setenv @var{VARIABLE} @var{value}} for
@command{export @var{VARIABLE}=@var{value}} if the Berkeley C shell is
your login shell.)

Here is a simple configuration for a site-wide GiNaC library assuming
everything is in default paths:

@example
$ export CXXFLAGS="-Wall -O2"
$ ./configure
@end example

And here is a configuration for a private static GiNaC library with
several components sitting in custom places (site-wide GCC and private
CLN).  The compiler is persuaded to be picky and full assertions and
debugging information are switched on:

@example
$ export CXX=/usr/local/gnu/bin/c++
$ export CPPFLAGS="$(CPPFLAGS) -I$(HOME)/include"
$ export CXXFLAGS="$(CXXFLAGS) -DDO_GINAC_ASSERT -ggdb -Wall -pedantic"
$ export LDFLAGS="$(LDFLAGS) -L$(HOME)/lib"
$ ./configure --disable-shared --prefix=$(HOME)
@end example


@node Building GiNaC, Installing GiNaC, Configuration, Installation
@c    node-name, next, previous, up
@section Building GiNaC
@cindex building GiNaC

After proper configuration you should just build the whole
library by typing
@example
$ make
@end example
at the command prompt and go for a cup of coffee.  The exact time it
takes to compile GiNaC depends not only on the speed of your machines
but also on other parameters, for instance what value for @env{CXXFLAGS}
you entered.  Optimization may be very time-consuming.

Just to make sure GiNaC works properly you may run a collection of
regression tests by typing

@example
$ make check
@end example

This will compile some sample programs, run them and check the output
for correctness.  The regression tests fall in three categories.  First,
the so called @emph{exams} are performed, simple tests where some
predefined input is evaluated (like a pupils' exam).  Second, the
@emph{checks} test the coherence of results among each other with
possible random input.  Third, some @emph{timings} are performed, which
benchmark some predefined problems with different sizes and display the
CPU time used in seconds.  Each individual test should return a message
@samp{passed}.  This is mostly intended to be a QA-check if something
was broken during development, not a sanity check of your system.  Some
of the tests in sections @emph{checks} and @emph{timings} may require
insane amounts of memory and CPU time.  Feel free to kill them if your
machine catches fire.  Another quite important intent is to allow people
to fiddle around with optimization.

Generally, the top-level Makefile runs recursively to the
subdirectories.  It is therefore safe to go into any subdirectory
(@code{doc/}, @code{ginsh/}, @dots{}) and simply type @code{make}
@var{target} there in case something went wrong.


@node Installing GiNaC, Basic Concepts, Building GiNaC, Installation
@c    node-name, next, previous, up
@section Installing GiNaC
@cindex installation

To install GiNaC on your system, simply type

@example
$ make install
@end example

As described in the section about configuration the files will be
installed in the following directories (the directories will be created
if they don't already exist):

@itemize @bullet

@item
@file{libginac.a} will go into @file{@var{PREFIX}/lib/} (or
@file{@var{LIBDIR}}) which defaults to @file{/usr/local/lib/}.
So will @file{libginac.so} unless the configure script was
given the option @option{--disable-shared}.  The proper symlinks
will be established as well.

@item
All the header files will be installed into @file{@var{PREFIX}/include/ginac/}
(or @file{@var{INCLUDEDIR}/ginac/}, if specified).

@item
All documentation (HTML and Postscript) will be stuffed into
@file{@var{PREFIX}/share/doc/GiNaC/} (or
@file{@var{DATADIR}/doc/GiNaC/}, if @var{DATADIR} was specified).

@end itemize

For the sake of completeness we will list some other useful make
targets: @command{make clean} deletes all files generated by
@command{make}, i.e. all the object files.  In addition @command{make
distclean} removes all files generated by the configuration and
@command{make maintainer-clean} goes one step further and deletes files
that may require special tools to rebuild (like the @command{libtool}
for instance).  Finally @command{make uninstall} removes the installed
library, header files and documentation@footnote{Uninstallation does not
work after you have called @command{make distclean} since the
@file{Makefile} is itself generated by the configuration from
@file{Makefile.in} and hence deleted by @command{make distclean}.  There
are two obvious ways out of this dilemma.  First, you can run the
configuration again with the same @var{PREFIX} thus creating a
@file{Makefile} with a working @samp{uninstall} target.  Second, you can
do it by hand since you now know where all the files went during
installation.}.


@node Basic Concepts, Expressions, Installing GiNaC, Top
@c    node-name, next, previous, up
@chapter Basic Concepts

This chapter will describe the different fundamental objects that can be
handled by GiNaC.  But before doing so, it is worthwhile introducing you
to the more commonly used class of expressions, representing a flexible
meta-class for storing all mathematical objects.

@menu
* Expressions::                  The fundamental GiNaC class.
* Automatic evaluation::         Evaluation and canonicalization.
* Error handling::               How the library reports errors.
* The Class Hierarchy::          Overview of GiNaC's classes.
* Symbols::                      Symbolic objects.
* Numbers::                      Numerical objects.
* Constants::                    Pre-defined constants.
* Fundamental containers::       Sums, products and powers.
* Lists::                        Lists of expressions.
* Mathematical functions::       Mathematical functions.
* Relations::                    Equality, Inequality and all that.
* Matrices::                     Matrices.
* Indexed objects::              Handling indexed quantities.
* Non-commutative objects::      Algebras with non-commutative products.
* Hash Maps::                    A faster alternative to std::map<>.
@end menu


@node Expressions, Automatic evaluation, Basic Concepts, Basic Concepts
@c    node-name, next, previous, up
@section Expressions
@cindex expression (class @code{ex})
@cindex @code{has()}

The most common class of objects a user deals with is the expression
@code{ex}, representing a mathematical object like a variable, number,
function, sum, product, etc@dots{}  Expressions may be put together to form
new expressions, passed as arguments to functions, and so on.  Here is a
little collection of valid expressions:

@example
ex MyEx1 = 5;                       // simple number
ex MyEx2 = x + 2*y;                 // polynomial in x and y
ex MyEx3 = (x + 1)/(x - 1);         // rational expression
ex MyEx4 = sin(x + 2*y) + 3*z + 41; // containing a function
ex MyEx5 = MyEx4 + 1;               // similar to above
@end example

Expressions are handles to other more fundamental objects, that often
contain other expressions thus creating a tree of expressions
(@xref{Internal Structures}, for particular examples).  Most methods on
@code{ex} therefore run top-down through such an expression tree.  For
example, the method @code{has()} scans recursively for occurrences of
something inside an expression.  Thus, if you have declared @code{MyEx4}
as in the example above @code{MyEx4.has(y)} will find @code{y} inside
the argument of @code{sin} and hence return @code{true}.

The next sections will outline the general picture of GiNaC's class
hierarchy and describe the classes of objects that are handled by
@code{ex}.

@subsection Note: Expressions and STL containers

GiNaC expressions (@code{ex} objects) have value semantics (they can be
assigned, reassigned and copied like integral types) but the operator
@code{<} doesn't provide a well-defined ordering on them. In STL-speak,
expressions are @samp{Assignable} but not @samp{LessThanComparable}.

This implies that in order to use expressions in sorted containers such as
@code{std::map<>} and @code{std::set<>} you have to supply a suitable
comparison predicate. GiNaC provides such a predicate, called
@code{ex_is_less}. For example, a set of expressions should be defined
as @code{std::set<ex, ex_is_less>}.

Unsorted containers such as @code{std::vector<>} and @code{std::list<>}
don't pose a problem. A @code{std::vector<ex>} works as expected.

@xref{Information About Expressions}, for more about comparing and ordering
expressions.


@node Automatic evaluation, Error handling, Expressions, Basic Concepts
@c    node-name, next, previous, up
@section Automatic evaluation and canonicalization of expressions
@cindex evaluation

GiNaC performs some automatic transformations on expressions, to simplify
them and put them into a canonical form. Some examples:

@example
ex MyEx1 = 2*x - 1 + x;  // 3*x-1
ex MyEx2 = x - x;        // 0
ex MyEx3 = cos(2*Pi);    // 1
ex MyEx4 = x*y/x;        // y
@end example

This behavior is usually referred to as @dfn{automatic} or @dfn{anonymous
evaluation}. GiNaC only performs transformations that are

@itemize @bullet
@item
at most of complexity
@tex
$O(n\log n)$
@end tex
@ifnottex
@math{O(n log n)}
@end ifnottex
@item
algebraically correct, possibly except for a set of measure zero (e.g.
@math{x/x} is transformed to @math{1} although this is incorrect for @math{x=0})
@end itemize

There are two types of automatic transformations in GiNaC that may not
behave in an entirely obvious way at first glance:

@itemize
@item
The terms of sums and products (and some other things like the arguments of
symmetric functions, the indices of symmetric tensors etc.) are re-ordered
into a canonical form that is deterministic, but not lexicographical or in
any other way easy to guess (it almost always depends on the number and
order of the symbols you define). However, constructing the same expression
twice, either implicitly or explicitly, will always result in the same
canonical form.
@item
Expressions of the form 'number times sum' are automatically expanded (this
has to do with GiNaC's internal representation of sums and products). For
example
@example
ex MyEx5 = 2*(x + y);   // 2*x+2*y
ex MyEx6 = z*(x + y);   // z*(x+y)
@end example
@end itemize

The general rule is that when you construct expressions, GiNaC automatically
creates them in canonical form, which might differ from the form you typed in
your program. This may create some awkward looking output (@samp{-y+x} instead
of @samp{x-y}) but allows for more efficient operation and usually yields
some immediate simplifications.

@cindex @code{eval()}
Internally, the anonymous evaluator in GiNaC is implemented by the methods

@example
ex ex::eval(int level = 0) const;
ex basic::eval(int level = 0) const;
@end example

but unless you are extending GiNaC with your own classes or functions, there
should never be any reason to call them explicitly. All GiNaC methods that
transform expressions, like @code{subs()} or @code{normal()}, automatically
re-evaluate their results.


@node Error handling, The Class Hierarchy, Automatic evaluation, Basic Concepts
@c    node-name, next, previous, up
@section Error handling
@cindex exceptions
@cindex @code{pole_error} (class)

GiNaC reports run-time errors by throwing C++ exceptions. All exceptions
generated by GiNaC are subclassed from the standard @code{exception} class
defined in the @file{<stdexcept>} header. In addition to the predefined
@code{logic_error}, @code{domain_error}, @code{out_of_range},
@code{invalid_argument}, @code{runtime_error}, @code{range_error} and
@code{overflow_error} types, GiNaC also defines a @code{pole_error}
exception that gets thrown when trying to evaluate a mathematical function
at a singularity.

The @code{pole_error} class has a member function

@example
int pole_error::degree() const;
@end example

that returns the order of the singularity (or 0 when the pole is
logarithmic or the order is undefined).

When using GiNaC it is useful to arrange for exceptions to be caught in
the main program even if you don't want to do any special error handling.
Otherwise whenever an error occurs in GiNaC, it will be delegated to the
default exception handler of your C++ compiler's run-time system which
usually only aborts the program without giving any information what went
wrong.

Here is an example for a @code{main()} function that catches and prints
exceptions generated by GiNaC:

@example
#include <iostream>
#include <stdexcept>
#include <ginac/ginac.h>
using namespace std;
using namespace GiNaC;

int main()
@{
    try @{
        ...
        // code using GiNaC
        ...
    @} catch (exception &p) @{
        cerr << p.what() << endl;
        return 1;
    @}
    return 0;
@}
@end example


@node The Class Hierarchy, Symbols, Error handling, Basic Concepts
@c    node-name, next, previous, up
@section The Class Hierarchy

GiNaC's class hierarchy consists of several classes representing
mathematical objects, all of which (except for @code{ex} and some
helpers) are internally derived from one abstract base class called
@code{basic}.  You do not have to deal with objects of class
@code{basic}, instead you'll be dealing with symbols, numbers,
containers of expressions and so on.

@cindex container
@cindex atom
To get an idea about what kinds of symbolic composites may be built we
have a look at the most important classes in the class hierarchy and
some of the relations among the classes:

@image{classhierarchy}

The abstract classes shown here (the ones without drop-shadow) are of no
interest for the user.  They are used internally in order to avoid code
duplication if two or more classes derived from them share certain
features.  An example is @code{expairseq}, a container for a sequence of
pairs each consisting of one expression and a number (@code{numeric}).
What @emph{is} visible to the user are the derived classes @code{add}
and @code{mul}, representing sums and products.  @xref{Internal
Structures}, where these two classes are described in more detail.  The
following table shortly summarizes what kinds of mathematical objects
are stored in the different classes:

@cartouche
@multitable @columnfractions .22 .78
@item @code{symbol} @tab Algebraic symbols @math{a}, @math{x}, @math{y}@dots{}
@item @code{constant} @tab Constants like 
@tex
$\pi$
@end tex
@ifnottex
@math{Pi}
@end ifnottex
@item @code{numeric} @tab All kinds of numbers, @math{42}, @math{7/3*I}, @math{3.14159}@dots{}
@item @code{add} @tab Sums like @math{x+y} or @math{a-(2*b)+3}
@item @code{mul} @tab Products like @math{x*y} or @math{2*a^2*(x+y+z)/b}
@item @code{ncmul} @tab Products of non-commutative objects
@item @code{power} @tab Exponentials such as @math{x^2}, @math{a^b}, 
@tex
$\sqrt{2}$
@end tex
@ifnottex
@code{sqrt(}@math{2}@code{)}
@end ifnottex
@dots{}
@item @code{pseries} @tab Power Series, e.g. @math{x-1/6*x^3+1/120*x^5+O(x^7)}
@item @code{function} @tab A symbolic function like
@tex
$\sin 2x$
@end tex
@ifnottex
@math{sin(2*x)}
@end ifnottex
@item @code{lst} @tab Lists of expressions @{@math{x}, @math{2*y}, @math{3+z}@}
@item @code{matrix} @tab @math{m}x@math{n} matrices of expressions
@item @code{relational} @tab A relation like the identity @math{x}@code{==}@math{y}
@item @code{indexed} @tab Indexed object like @math{A_ij}
@item @code{tensor} @tab Special tensor like the delta and metric tensors
@item @code{idx} @tab Index of an indexed object
@item @code{varidx} @tab Index with variance
@item @code{spinidx} @tab Index with variance and dot (used in Weyl-van-der-Waerden spinor formalism)
@item @code{wildcard} @tab Wildcard for pattern matching
@item @code{structure} @tab Template for user-defined classes
@end multitable
@end cartouche


@node Symbols, Numbers, The Class Hierarchy, Basic Concepts
@c    node-name, next, previous, up
@section Symbols
@cindex @code{symbol} (class)
@cindex hierarchy of classes

@cindex atom
Symbolic indeterminates, or @dfn{symbols} for short, are for symbolic
manipulation what atoms are for chemistry.

A typical symbol definition looks like this:
@example
symbol x("x");
@end example

This definition actually contains three very different things:
@itemize
@item a C++ variable named @code{x}
@item a @code{symbol} object stored in this C++ variable; this object
  represents the symbol in a GiNaC expression
@item the string @code{"x"} which is the name of the symbol, used (almost)
  exclusively for printing expressions holding the symbol
@end itemize

Symbols have an explicit name, supplied as a string during construction,
because in C++, variable names can't be used as values, and the C++ compiler
throws them away during compilation.

It is possible to omit the symbol name in the definition:
@example
symbol x;
@end example

In this case, GiNaC will assign the symbol an internal, unique name of the
form @code{symbolNNN}. This won't affect the usability of the symbol but
the output of your calculations will become more readable if you give your
symbols sensible names (for intermediate expressions that are only used
internally such anonymous symbols can be quite useful, however).

Now, here is one important property of GiNaC that differentiates it from
other computer algebra programs you may have used: GiNaC does @emph{not} use
the names of symbols to tell them apart, but a (hidden) serial number that
is unique for each newly created @code{symbol} object. In you want to use
one and the same symbol in different places in your program, you must only
create one @code{symbol} object and pass that around. If you create another
symbol, even if it has the same name, GiNaC will treat it as a different
indeterminate.

Observe:
@example
ex f(int n)
@{
    symbol x("x");
    return pow(x, n);
@}

int main()
@{
    symbol x("x");
    ex e = f(6);

    cout << e << endl;
     // prints "x^6" which looks right, but...

    cout << e.degree(x) << endl;
     // ...this doesn't work. The symbol "x" here is different from the one
     // in f() and in the expression returned by f(). Consequently, it
     // prints "0".
@}
@end example

One possibility to ensure that @code{f()} and @code{main()} use the same
symbol is to pass the symbol as an argument to @code{f()}:
@example
ex f(int n, const ex & x)
@{
    return pow(x, n);
@}

int main()
@{
    symbol x("x");

    // Now, f() uses the same symbol.
    ex e = f(6, x);

    cout << e.degree(x) << endl;
     // prints "6", as expected
@}
@end example

Another possibility would be to define a global symbol @code{x} that is used
by both @code{f()} and @code{main()}. If you are using global symbols and
multiple compilation units you must take special care, however. Suppose
that you have a header file @file{globals.h} in your program that defines
a @code{symbol x("x");}. In this case, every unit that includes
@file{globals.h} would also get its own definition of @code{x} (because
header files are just inlined into the source code by the C++ preprocessor),
and hence you would again end up with multiple equally-named, but different,
symbols. Instead, the @file{globals.h} header should only contain a
@emph{declaration} like @code{extern symbol x;}, with the definition of
@code{x} moved into a C++ source file such as @file{globals.cpp}.

A different approach to ensuring that symbols used in different parts of
your program are identical is to create them with a @emph{factory} function
like this one:
@example
const symbol & get_symbol(const string & s)
@{
    static map<string, symbol> directory;
    map<string, symbol>::iterator i = directory.find(s);
    if (i != directory.end())
        return i->second;
    else
        return directory.insert(make_pair(s, symbol(s))).first->second;
@}
@end example

This function returns one newly constructed symbol for each name that is
passed in, and it returns the same symbol when called multiple times with
the same name. Using this symbol factory, we can rewrite our example like
this:
@example
ex f(int n)
@{
    return pow(get_symbol("x"), n);
@}

int main()
@{
    ex e = f(6);

    // Both calls of get_symbol("x") yield the same symbol.
    cout << e.degree(get_symbol("x")) << endl;
     // prints "6"
@}
@end example

Instead of creating symbols from strings we could also have
@code{get_symbol()} take, for example, an integer number as its argument.
In this case, we would probably want to give the generated symbols names
that include this number, which can be accomplished with the help of an
@code{ostringstream}.

In general, if you're getting weird results from GiNaC such as an expression
@samp{x-x} that is not simplified to zero, you should check your symbol
definitions.

As we said, the names of symbols primarily serve for purposes of expression
output. But there are actually two instances where GiNaC uses the names for
identifying symbols: When constructing an expression from a string, and when
recreating an expression from an archive (@pxref{Input/Output}).

In addition to its name, a symbol may contain a special string that is used
in LaTeX output:
@example
symbol x("x", "\\Box");
@end example

This creates a symbol that is printed as "@code{x}" in normal output, but
as "@code{\Box}" in LaTeX code (@xref{Input/Output}, for more
information about the different output formats of expressions in GiNaC).
GiNaC automatically creates proper LaTeX code for symbols having names of
greek letters (@samp{alpha}, @samp{mu}, etc.).

@cindex @code{subs()}
Symbols in GiNaC can't be assigned values. If you need to store results of
calculations and give them a name, use C++ variables of type @code{ex}.
If you want to replace a symbol in an expression with something else, you
can invoke the expression's @code{.subs()} method
(@pxref{Substituting Expressions}).

@cindex @code{realsymbol()}
By default, symbols are expected to stand in for complex values, i.e. they live
in the complex domain.  As a consequence, operations like complex conjugation,
for example (@pxref{Complex Conjugation}), do @emph{not} evaluate if applied
to such symbols. Likewise @code{log(exp(x))} does not evaluate to @code{x},
because of the unknown imaginary part of @code{x}.
On the other hand, if you are sure that your symbols will hold only real values, you
would like to have such functions evaluated. Therefore GiNaC allows you to specify
the domain of the symbol. Instead of @code{symbol x("x");} you can write
@code{realsymbol x("x");} to tell GiNaC that @code{x} stands in for real values.


@node Numbers, Constants, Symbols, Basic Concepts
@c    node-name, next, previous, up
@section Numbers
@cindex @code{numeric} (class)

@cindex GMP
@cindex CLN
@cindex rational
@cindex fraction
For storing numerical things, GiNaC uses Bruno Haible's library CLN.
The classes therein serve as foundation classes for GiNaC.  CLN stands
for Class Library for Numbers or alternatively for Common Lisp Numbers.
In order to find out more about CLN's internals, the reader is referred to
the documentation of that library.  @inforef{Introduction, , cln}, for
more information. Suffice to say that it is by itself build on top of
another library, the GNU Multiple Precision library GMP, which is an
extremely fast library for arbitrary long integers and rationals as well
as arbitrary precision floating point numbers.  It is very commonly used
by several popular cryptographic applications.  CLN extends GMP by
several useful things: First, it introduces the complex number field
over either reals (i.e. floating point numbers with arbitrary precision)
or rationals.  Second, it automatically converts rationals to integers
if the denominator is unity and complex numbers to real numbers if the
imaginary part vanishes and also correctly treats algebraic functions.
Third it provides good implementations of state-of-the-art algorithms
for all trigonometric and hyperbolic functions as well as for
calculation of some useful constants.

The user can construct an object of class @code{numeric} in several
ways.  The following example shows the four most important constructors.
It uses construction from C-integer, construction of fractions from two
integers, construction from C-float and construction from a string:

@example
#include <iostream>
#include <ginac/ginac.h>
using namespace GiNaC;

int main()
@{
    numeric two = 2;                      // exact integer 2
    numeric r(2,3);                       // exact fraction 2/3
    numeric e(2.71828);                   // floating point number
    numeric p = "3.14159265358979323846"; // constructor from string
    // Trott's constant in scientific notation:
    numeric trott("1.0841015122311136151E-2");
    
    std::cout << two*p << std::endl;  // floating point 6.283...
    ...
@end example

@cindex @code{I}
@cindex complex numbers
The imaginary unit in GiNaC is a predefined @code{numeric} object with the
name @code{I}:

@example
    ...
    numeric z1 = 2-3*I;                    // exact complex number 2-3i
    numeric z2 = 5.9+1.6*I;                // complex floating point number
@}
@end example

It may be tempting to construct fractions by writing @code{numeric r(3/2)}.
This would, however, call C's built-in operator @code{/} for integers
first and result in a numeric holding a plain integer 1.  @strong{Never
use the operator @code{/} on integers} unless you know exactly what you
are doing!  Use the constructor from two integers instead, as shown in
the example above.  Writing @code{numeric(1)/2} may look funny but works
also.

@cindex @code{Digits}
@cindex accuracy
We have seen now the distinction between exact numbers and floating
point numbers.  Clearly, the user should never have to worry about
dynamically created exact numbers, since their `exactness' always
determines how they ought to be handled, i.e. how `long' they are.  The
situation is different for floating point numbers.  Their accuracy is
controlled by one @emph{global} variable, called @code{Digits}.  (For
those readers who know about Maple: it behaves very much like Maple's
@code{Digits}).  All objects of class numeric that are constructed from
then on will be stored with a precision matching that number of decimal
digits:

@example
#include <iostream>
#include <ginac/ginac.h>
using namespace std;
using namespace GiNaC;

void foo()
@{
    numeric three(3.0), one(1.0);
    numeric x = one/three;

    cout << "in " << Digits << " digits:" << endl;
    cout << x << endl;
    cout << Pi.evalf() << endl;
@}

int main()
@{
    foo();
    Digits = 60;
    foo();
    return 0;
@}
@end example

The above example prints the following output to screen:

@example
in 17 digits:
0.33333333333333333334
3.1415926535897932385
in 60 digits:
0.33333333333333333333333333333333333333333333333333333333333333333334
3.1415926535897932384626433832795028841971693993751058209749445923078
@end example

@cindex rounding
Note that the last number is not necessarily rounded as you would
naively expect it to be rounded in the decimal system.  But note also,
that in both cases you got a couple of extra digits.  This is because
numbers are internally stored by CLN as chunks of binary digits in order
to match your machine's word size and to not waste precision.  Thus, on
architectures with different word size, the above output might even
differ with regard to actually computed digits.

It should be clear that objects of class @code{numeric} should be used
for constructing numbers or for doing arithmetic with them.  The objects
one deals with most of the time are the polymorphic expressions @code{ex}.

@subsection Tests on numbers

Once you have declared some numbers, assigned them to expressions and
done some arithmetic with them it is frequently desired to retrieve some
kind of information from them like asking whether that number is
integer, rational, real or complex.  For those cases GiNaC provides
several useful methods.  (Internally, they fall back to invocations of
certain CLN functions.)

As an example, let's construct some rational number, multiply it with
some multiple of its denominator and test what comes out:

@example
#include <iostream>
#include <ginac/ginac.h>
using namespace std;
using namespace GiNaC;

// some very important constants:
const numeric twentyone(21);
const numeric ten(10);
const numeric five(5);

int main()
@{
    numeric answer = twentyone;

    answer /= five;
    cout << answer.is_integer() << endl;  // false, it's 21/5
    answer *= ten;
    cout << answer.is_integer() << endl;  // true, it's 42 now!
@}
@end example

Note that the variable @code{answer} is constructed here as an integer
by @code{numeric}'s copy constructor but in an intermediate step it
holds a rational number represented as integer numerator and integer
denominator.  When multiplied by 10, the denominator becomes unity and
the result is automatically converted to a pure integer again.
Internally, the underlying CLN is responsible for this behavior and we
refer the reader to CLN's documentation.  Suffice to say that
the same behavior applies to complex numbers as well as return values of
certain functions.  Complex numbers are automatically converted to real
numbers if the imaginary part becomes zero.  The full set of tests that
can be applied is listed in the following table.

@cartouche
@multitable @columnfractions .30 .70
@item @strong{Method} @tab @strong{Returns true if the object is@dots{}}
@item @code{.is_zero()}
@tab @dots{}equal to zero
@item @code{.is_positive()}
@tab @dots{}not complex and greater than 0
@item @code{.is_integer()}
@tab @dots{}a (non-complex) integer
@item @code{.is_pos_integer()}
@tab @dots{}an integer and greater than 0
@item @code{.is_nonneg_integer()}
@tab @dots{}an integer and greater equal 0
@item @code{.is_even()}
@tab @dots{}an even integer
@item @code{.is_odd()}
@tab @dots{}an odd integer
@item @code{.is_prime()}
@tab @dots{}a prime integer (probabilistic primality test)
@item @code{.is_rational()}
@tab @dots{}an exact rational number (integers are rational, too)
@item @code{.is_real()}
@tab @dots{}a real integer, rational or float (i.e. is not complex)
@item @code{.is_cinteger()}
@tab @dots{}a (complex) integer (such as @math{2-3*I})
@item @code{.is_crational()}
@tab @dots{}an exact (complex) rational number (such as @math{2/3+7/2*I})
@end multitable
@end cartouche

@subsection Numeric functions

The following functions can be applied to @code{numeric} objects and will be
evaluated immediately:

@cartouche
@multitable @columnfractions .30 .70
@item @strong{Name} @tab @strong{Function}
@item @code{inverse(z)}
@tab returns @math{1/z}
@cindex @code{inverse()} (numeric)
@item @code{pow(a, b)}
@tab exponentiation @math{a^b}
@item @code{abs(z)}
@tab absolute value
@item @code{real(z)}
@tab real part
@cindex @code{real()}
@item @code{imag(z)}
@tab imaginary part
@cindex @code{imag()}
@item @code{csgn(z)}
@tab complex sign (returns an @code{int})
@item @code{numer(z)}
@tab numerator of rational or complex rational number
@item @code{denom(z)}
@tab denominator of rational or complex rational number
@item @code{sqrt(z)}
@tab square root
@item @code{isqrt(n)}
@tab integer square root
@cindex @code{isqrt()}
@item @code{sin(z)}
@tab sine
@item @code{cos(z)}
@tab cosine
@item @code{tan(z)}
@tab tangent
@item @code{asin(z)}
@tab inverse sine
@item @code{acos(z)}
@tab inverse cosine
@item @code{atan(z)}
@tab inverse tangent
@item @code{atan(y, x)}
@tab inverse tangent with two arguments
@item @code{sinh(z)}
@tab hyperbolic sine
@item @code{cosh(z)}
@tab hyperbolic cosine
@item @code{tanh(z)}
@tab hyperbolic tangent
@item @code{asinh(z)}
@tab inverse hyperbolic sine
@item @code{acosh(z)}
@tab inverse hyperbolic cosine
@item @code{atanh(z)}
@tab inverse hyperbolic tangent
@item @code{exp(z)}
@tab exponential function
@item @code{log(z)}
@tab natural logarithm
@item @code{Li2(z)}
@tab dilogarithm
@item @code{zeta(z)}
@tab Riemann's zeta function
@item @code{tgamma(z)}
@tab gamma function
@item @code{lgamma(z)}
@tab logarithm of gamma function
@item @code{psi(z)}
@tab psi (digamma) function
@item @code{psi(n, z)}
@tab derivatives of psi function (polygamma functions)
@item @code{factorial(n)}
@tab factorial function @math{n!}
@item @code{doublefactorial(n)}
@tab double factorial function @math{n!!}
@cindex @code{doublefactorial()}
@item @code{binomial(n, k)}
@tab binomial coefficients
@item @code{bernoulli(n)}
@tab Bernoulli numbers
@cindex @code{bernoulli()}
@item @code{fibonacci(n)}
@tab Fibonacci numbers
@cindex @code{fibonacci()}
@item @code{mod(a, b)}
@tab modulus in positive representation (in the range @code{[0, abs(b)-1]} with the sign of b, or zero)
@cindex @code{mod()}
@item @code{smod(a, b)}
@tab modulus in symmetric representation (in the range @code{[-iquo(abs(b)-1, 2), iquo(abs(b), 2)]})
@cindex @code{smod()}
@item @code{irem(a, b)}
@tab integer remainder (has the sign of @math{a}, or is zero)
@cindex @code{irem()}
@item @code{irem(a, b, q)}
@tab integer remainder and quotient, @code{irem(a, b, q) == a-q*b}
@item @code{iquo(a, b)}
@tab integer quotient
@cindex @code{iquo()}
@item @code{iquo(a, b, r)}
@tab integer quotient and remainder, @code{r == a-iquo(a, b)*b}
@item @code{gcd(a, b)}
@tab greatest common divisor
@item @code{lcm(a, b)}
@tab least common multiple
@end multitable
@end cartouche

Most of these functions are also available as symbolic functions that can be
used in expressions (@pxref{Mathematical functions}) or, like @code{gcd()},
as polynomial algorithms.

@subsection Converting numbers

Sometimes it is desirable to convert a @code{numeric} object back to a
built-in arithmetic type (@code{int}, @code{double}, etc.). The @code{numeric}
class provides a couple of methods for this purpose:

@cindex @code{to_int()}
@cindex @code{to_long()}
@cindex @code{to_double()}
@cindex @code{to_cl_N()}
@example
int numeric::to_int() const;
long numeric::to_long() const;
double numeric::to_double() const;
cln::cl_N numeric::to_cl_N() const;
@end example

@code{to_int()} and @code{to_long()} only work when the number they are
applied on is an exact integer. Otherwise the program will halt with a
message like @samp{Not a 32-bit integer}. @code{to_double()} applied on a
rational number will return a floating-point approximation. Both
@code{to_int()/to_long()} and @code{to_double()} discard the imaginary
part of complex numbers.


@node Constants, Fundamental containers, Numbers, Basic Concepts
@c    node-name, next, previous, up
@section Constants
@cindex @code{constant} (class)

@cindex @code{Pi}
@cindex @code{Catalan}
@cindex @code{Euler}
@cindex @code{evalf()}
Constants behave pretty much like symbols except that they return some
specific number when the method @code{.evalf()} is called.

The predefined known constants are:

@cartouche
@multitable @columnfractions .14 .30 .56
@item @strong{Name} @tab @strong{Common Name} @tab @strong{Numerical Value (to 35 digits)}
@item @code{Pi}
@tab Archimedes' constant
@tab 3.14159265358979323846264338327950288
@item @code{Catalan}
@tab Catalan's constant
@tab 0.91596559417721901505460351493238411
@item @code{Euler}
@tab Euler's (or Euler-Mascheroni) constant
@tab 0.57721566490153286060651209008240243
@end multitable
@end cartouche


@node Fundamental containers, Lists, Constants, Basic Concepts
@c    node-name, next, previous, up
@section Sums, products and powers
@cindex polynomial
@cindex @code{add}
@cindex @code{mul}
@cindex @code{power}

Simple rational expressions are written down in GiNaC pretty much like
in other CAS or like expressions involving numerical variables in C.
The necessary operators @code{+}, @code{-}, @code{*} and @code{/} have
been overloaded to achieve this goal.  When you run the following
code snippet, the constructor for an object of type @code{mul} is
automatically called to hold the product of @code{a} and @code{b} and
then the constructor for an object of type @code{add} is called to hold
the sum of that @code{mul} object and the number one:

@example
    ...
    symbol a("a"), b("b");
    ex MyTerm = 1+a*b;
    ...
@end example

@cindex @code{pow()}
For exponentiation, you have already seen the somewhat clumsy (though C-ish)
statement @code{pow(x,2);} to represent @code{x} squared.  This direct
construction is necessary since we cannot safely overload the constructor
@code{^} in C++ to construct a @code{power} object.  If we did, it would
have several counterintuitive and undesired effects:

@itemize @bullet
@item
Due to C's operator precedence, @code{2*x^2} would be parsed as @code{(2*x)^2}.
@item
Due to the binding of the operator @code{^}, @code{x^a^b} would result in
@code{(x^a)^b}. This would be confusing since most (though not all) other CAS
interpret this as @code{x^(a^b)}.
@item
Also, expressions involving integer exponents are very frequently used,
which makes it even more dangerous to overload @code{^} since it is then
hard to distinguish between the semantics as exponentiation and the one
for exclusive or.  (It would be embarrassing to return @code{1} where one
has requested @code{2^3}.)
@end itemize

@cindex @command{ginsh}
All effects are contrary to mathematical notation and differ from the
way most other CAS handle exponentiation, therefore overloading @code{^}
is ruled out for GiNaC's C++ part.  The situation is different in
@command{ginsh}, there the exponentiation-@code{^} exists.  (Also note
that the other frequently used exponentiation operator @code{**} does
not exist at all in C++).

To be somewhat more precise, objects of the three classes described
here, are all containers for other expressions.  An object of class
@code{power} is best viewed as a container with two slots, one for the
basis, one for the exponent.  All valid GiNaC expressions can be
inserted.  However, basic transformations like simplifying
@code{pow(pow(x,2),3)} to @code{x^6} automatically are only performed
when this is mathematically possible.  If we replace the outer exponent
three in the example by some symbols @code{a}, the simplification is not
safe and will not be performed, since @code{a} might be @code{1/2} and
@code{x} negative.

Objects of type @code{add} and @code{mul} are containers with an
arbitrary number of slots for expressions to be inserted.  Again, simple
and safe simplifications are carried out like transforming
@code{3*x+4-x} to @code{2*x+4}.


@node Lists, Mathematical functions, Fundamental containers, Basic Concepts
@c    node-name, next, previous, up
@section Lists of expressions
@cindex @code{lst} (class)
@cindex lists
@cindex @code{nops()}
@cindex @code{op()}
@cindex @code{append()}
@cindex @code{prepend()}
@cindex @code{remove_first()}
@cindex @code{remove_last()}
@cindex @code{remove_all()}

The GiNaC class @code{lst} serves for holding a @dfn{list} of arbitrary
expressions. They are not as ubiquitous as in many other computer algebra
packages, but are sometimes used to supply a variable number of arguments of
the same type to GiNaC methods such as @code{subs()} and some @code{matrix}
constructors, so you should have a basic understanding of them.

Lists can be constructed by assigning a comma-separated sequence of
expressions:

@example
@{
    symbol x("x"), y("y");
    lst l;
    l = x, 2, y, x+y;
    // now, l is a list holding the expressions 'x', '2', 'y', and 'x+y',
    // in that order
    ...
@end example

There are also constructors that allow direct creation of lists of up to
16 expressions, which is often more convenient but slightly less efficient:

@example
    ...
    // This produces the same list 'l' as above:
    // lst l(x, 2, y, x+y);
    // lst l = lst(x, 2, y, x+y);
    ...
@end example

Use the @code{nops()} method to determine the size (number of expressions) of
a list and the @code{op()} method or the @code{[]} operator to access
individual elements:

@example
    ...
    cout << l.nops() << endl;                // prints '4'
    cout << l.op(2) << " " << l[0] << endl;  // prints 'y x'
    ...
@end example

As with the standard @code{list<T>} container, accessing random elements of a
@code{lst} is generally an operation of order @math{O(N)}. Faster read-only
sequential access to the elements of a list is possible with the
iterator types provided by the @code{lst} class:

@example
typedef ... lst::const_iterator;
typedef ... lst::const_reverse_iterator;
lst::const_iterator lst::begin() const;
lst::const_iterator lst::end() const;
lst::const_reverse_iterator lst::rbegin() const;
lst::const_reverse_iterator lst::rend() const;
@end example

For example, to print the elements of a list individually you can use:

@example
    ...
    // O(N)
    for (lst::const_iterator i = l.begin(); i != l.end(); ++i)
        cout << *i << endl;
    ...
@end example

which is one order faster than

@example
    ...
    // O(N^2)
    for (size_t i = 0; i < l.nops(); ++i)
        cout << l.op(i) << endl;
    ...
@end example

These iterators also allow you to use some of the algorithms provided by
the C++ standard library:

@example
    ...
    // print the elements of the list (requires #include <iterator>)
    std::copy(l.begin(), l.end(), ostream_iterator<ex>(cout, "\n"));

    // sum up the elements of the list (requires #include <numeric>)
    ex sum = std::accumulate(l.begin(), l.end(), ex(0));
    cout << sum << endl;  // prints '2+2*x+2*y'
    ...
@end example

@code{lst} is one of the few GiNaC classes that allow in-place modifications
(the only other one is @code{matrix}). You can modify single elements:

@example
    ...
    l[1] = 42;       // l is now @{x, 42, y, x+y@}
    l.let_op(1) = 7; // l is now @{x, 7, y, x+y@}
    ...
@end example

You can append or prepend an expression to a list with the @code{append()}
and @code{prepend()} methods:

@example
    ...
    l.append(4*x);   // l is now @{x, 7, y, x+y, 4*x@}
    l.prepend(0);    // l is now @{0, x, 7, y, x+y, 4*x@}
    ...
@end example

You can remove the first or last element of a list with @code{remove_first()}
and @code{remove_last()}:

@example
    ...
    l.remove_first();   // l is now @{x, 7, y, x+y, 4*x@}
    l.remove_last();    // l is now @{x, 7, y, x+y@}
    ...
@end example

You can remove all the elements of a list with @code{remove_all()}:

@example
    ...
    l.remove_all();     // l is now empty
    ...
@end example

You can bring the elements of a list into a canonical order with @code{sort()}:

@example
    ...
    lst l1, l2;
    l1 = x, 2, y, x+y;
    l2 = 2, x+y, x, y;
    l1.sort();
    l2.sort();
    // l1 and l2 are now equal
    ...
@end example

Finally, you can remove all but the first element of consecutive groups of
elements with @code{unique()}:

@example
    ...
    lst l3;
    l3 = x, 2, 2, 2, y, x+y, y+x;
    l3.unique();        // l3 is now @{x, 2, y, x+y@}
@}
@end example


@node Mathematical functions, Relations, Lists, Basic Concepts
@c    node-name, next, previous, up
@section Mathematical functions
@cindex @code{function} (class)
@cindex trigonometric function
@cindex hyperbolic function

There are quite a number of useful functions hard-wired into GiNaC.  For
instance, all trigonometric and hyperbolic functions are implemented
(@xref{Built-in Functions}, for a complete list).

These functions (better called @emph{pseudofunctions}) are all objects
of class @code{function}.  They accept one or more expressions as
arguments and return one expression.  If the arguments are not
numerical, the evaluation of the function may be halted, as it does in
the next example, showing how a function returns itself twice and
finally an expression that may be really useful:

@cindex Gamma function
@cindex @code{subs()}
@example
    ...
    symbol x("x"), y("y");    
    ex foo = x+y/2;
    cout << tgamma(foo) << endl;
     // -> tgamma(x+(1/2)*y)
    ex bar = foo.subs(y==1);
    cout << tgamma(bar) << endl;
     // -> tgamma(x+1/2)
    ex foobar = bar.subs(x==7);
    cout << tgamma(foobar) << endl;
     // -> (135135/128)*Pi^(1/2)
    ...
@end example

Besides evaluation most of these functions allow differentiation, series
expansion and so on.  Read the next chapter in order to learn more about
this.

It must be noted that these pseudofunctions are created by inline
functions, where the argument list is templated.  This means that
whenever you call @code{GiNaC::sin(1)} it is equivalent to
@code{sin(ex(1))} and will therefore not result in a floating point
number.  Unless of course the function prototype is explicitly
overridden -- which is the case for arguments of type @code{numeric}
(not wrapped inside an @code{ex}).  Hence, in order to obtain a floating
point number of class @code{numeric} you should call
@code{sin(numeric(1))}.  This is almost the same as calling
@code{sin(1).evalf()} except that the latter will return a numeric
wrapped inside an @code{ex}.


@node Relations, Matrices, Mathematical functions, Basic Concepts
@c    node-name, next, previous, up
@section Relations
@cindex @code{relational} (class)

Sometimes, a relation holding between two expressions must be stored
somehow.  The class @code{relational} is a convenient container for such
purposes.  A relation is by definition a container for two @code{ex} and
a relation between them that signals equality, inequality and so on.
They are created by simply using the C++ operators @code{==}, @code{!=},
@code{<}, @code{<=}, @code{>} and @code{>=} between two expressions.

@xref{Mathematical functions}, for examples where various applications
of the @code{.subs()} method show how objects of class relational are
used as arguments.  There they provide an intuitive syntax for
substitutions.  They are also used as arguments to the @code{ex::series}
method, where the left hand side of the relation specifies the variable
to expand in and the right hand side the expansion point.  They can also
be used for creating systems of equations that are to be solved for
unknown variables.  But the most common usage of objects of this class
is rather inconspicuous in statements of the form @code{if
(expand(pow(a+b,2))==a*a+2*a*b+b*b) @{...@}}.  Here, an implicit
conversion from @code{relational} to @code{bool} takes place.  Note,
however, that @code{==} here does not perform any simplifications, hence
@code{expand()} must be called explicitly.


@node Matrices, Indexed objects, Relations, Basic Concepts
@c    node-name, next, previous, up
@section Matrices
@cindex @code{matrix} (class)

A @dfn{matrix} is a two-dimensional array of expressions. The elements of a
matrix with @math{m} rows and @math{n} columns are accessed with two
@code{unsigned} indices, the first one in the range 0@dots{}@math{m-1}, the
second one in the range 0@dots{}@math{n-1}.

There are a couple of ways to construct matrices, with or without preset
elements. The constructor

@example
matrix::matrix(unsigned r, unsigned c);
@end example

creates a matrix with @samp{r} rows and @samp{c} columns with all elements
set to zero.

The fastest way to create a matrix with preinitialized elements is to assign
a list of comma-separated expressions to an empty matrix (see below for an
example). But you can also specify the elements as a (flat) list with

@example
matrix::matrix(unsigned r, unsigned c, const lst & l);
@end example

The function

@cindex @code{lst_to_matrix()}
@example
ex lst_to_matrix(const lst & l);
@end example

constructs a matrix from a list of lists, each list representing a matrix row.

There is also a set of functions for creating some special types of
matrices:

@cindex @code{diag_matrix()}
@cindex @code{unit_matrix()}
@cindex @code{symbolic_matrix()}
@example
ex diag_matrix(const lst & l);
ex unit_matrix(unsigned x);
ex unit_matrix(unsigned r, unsigned c);
ex symbolic_matrix(unsigned r, unsigned c, const string & base_name);
ex symbolic_matrix(unsigned r, unsigned c, const string & base_name, const string & tex_base_name);
@end example

@code{diag_matrix()} constructs a diagonal matrix given the list of diagonal
elements. @code{unit_matrix()} creates an @samp{x} by @samp{x} (or @samp{r}
by @samp{c}) unit matrix. And finally, @code{symbolic_matrix} constructs a
matrix filled with newly generated symbols made of the specified base name
and the position of each element in the matrix.

Matrix elements can be accessed and set using the parenthesis (function call)
operator:

@example
const ex & matrix::operator()(unsigned r, unsigned c) const;
ex & matrix::operator()(unsigned r, unsigned c);
@end example

It is also possible to access the matrix elements in a linear fashion with
the @code{op()} method. But C++-style subscripting with square brackets
@samp{[]} is not available.

Here are a couple of examples for constructing matrices:

@example
@{
    symbol a("a"), b("b");

    matrix M(2, 2);
    M = a, 0,
        0, b;
    cout << M << endl;
     // -> [[a,0],[0,b]]

    matrix M2(2, 2);
    M2(0, 0) = a;
    M2(1, 1) = b;
    cout << M2 << endl;
     // -> [[a,0],[0,b]]

    cout << matrix(2, 2, lst(a, 0, 0, b)) << endl;
     // -> [[a,0],[0,b]]

    cout << lst_to_matrix(lst(lst(a, 0), lst(0, b))) << endl;
     // -> [[a,0],[0,b]]

    cout << diag_matrix(lst(a, b)) << endl;
     // -> [[a,0],[0,b]]

    cout << unit_matrix(3) << endl;
     // -> [[1,0,0],[0,1,0],[0,0,1]]

    cout << symbolic_matrix(2, 3, "x") << endl;
     // -> [[x00,x01,x02],[x10,x11,x12]]
@}
@end example

@cindex @code{transpose()}
There are three ways to do arithmetic with matrices. The first (and most
direct one) is to use the methods provided by the @code{matrix} class:

@example
matrix matrix::add(const matrix & other) const;
matrix matrix::sub(const matrix & other) const;
matrix matrix::mul(const matrix & other) const;
matrix matrix::mul_scalar(const ex & other) const;
matrix matrix::pow(const ex & expn) const;
matrix matrix::transpose() const;
@end example

All of these methods return the result as a new matrix object. Here is an
example that calculates @math{A*B-2*C} for three matrices @math{A}, @math{B}
and @math{C}:

@example
@{
    matrix A(2, 2), B(2, 2), C(2, 2);
    A =  1, 2,
         3, 4;
    B = -1, 0,
         2, 1;
    C =  8, 4,
         2, 1;

    matrix result = A.mul(B).sub(C.mul_scalar(2));
    cout << result << endl;
     // -> [[-13,-6],[1,2]]
    ...
@}
@end example

@cindex @code{evalm()}
The second (and probably the most natural) way is to construct an expression
containing matrices with the usual arithmetic operators and @code{pow()}.
For efficiency reasons, expressions with sums, products and powers of
matrices are not automatically evaluated in GiNaC. You have to call the
method

@example
ex ex::evalm() const;
@end example

to obtain the result:

@example
@{
    ...
    ex e = A*B - 2*C;
    cout << e << endl;
     // -> [[1,2],[3,4]]*[[-1,0],[2,1]]-2*[[8,4],[2,1]]
    cout << e.evalm() << endl;
     // -> [[-13,-6],[1,2]]
    ...
@}
@end example

The non-commutativity of the product @code{A*B} in this example is
automatically recognized by GiNaC. There is no need to use a special
operator here. @xref{Non-commutative objects}, for more information about
dealing with non-commutative expressions.

Finally, you can work with indexed matrices and call @code{simplify_indexed()}
to perform the arithmetic:

@example
@{
    ...
    idx i(symbol("i"), 2), j(symbol("j"), 2), k(symbol("k"), 2);
    e = indexed(A, i, k) * indexed(B, k, j) - 2 * indexed(C, i, j);
    cout << e << endl;
     // -> -2*[[8,4],[2,1]].i.j+[[-1,0],[2,1]].k.j*[[1,2],[3,4]].i.k
    cout << e.simplify_indexed() << endl;
     // -> [[-13,-6],[1,2]].i.j
@}
@end example

Using indices is most useful when working with rectangular matrices and
one-dimensional vectors because you don't have to worry about having to
transpose matrices before multiplying them. @xref{Indexed objects}, for
more information about using matrices with indices, and about indices in
general.

The @code{matrix} class provides a couple of additional methods for
computing determinants, traces, characteristic polynomials and ranks:

@cindex @code{determinant()}
@cindex @code{trace()}
@cindex @code{charpoly()}
@cindex @code{rank()}
@example
ex matrix::determinant(unsigned algo=determinant_algo::automatic) const;
ex matrix::trace() const;
ex matrix::charpoly(const ex & lambda) const;
unsigned matrix::rank() const;
@end example

The @samp{algo} argument of @code{determinant()} allows to select
between different algorithms for calculating the determinant.  The
asymptotic speed (as parametrized by the matrix size) can greatly differ
between those algorithms, depending on the nature of the matrix'
entries.  The possible values are defined in the @file{flags.h} header
file.  By default, GiNaC uses a heuristic to automatically select an
algorithm that is likely (but not guaranteed) to give the result most
quickly.

@cindex @code{inverse()} (matrix)
@cindex @code{solve()}
Matrices may also be inverted using the @code{ex matrix::inverse()}
method and linear systems may be solved with:

@example
matrix matrix::solve(const matrix & vars, const matrix & rhs, unsigned algo=solve_algo::automatic) const;
@end example

Assuming the matrix object this method is applied on is an @code{m}
times @code{n} matrix, then @code{vars} must be a @code{n} times
@code{p} matrix of symbolic indeterminates and @code{rhs} a @code{m}
times @code{p} matrix.  The returned matrix then has dimension @code{n}
times @code{p} and in the case of an underdetermined system will still
contain some of the indeterminates from @code{vars}.  If the system is
overdetermined, an exception is thrown.


@node Indexed objects, Non-commutative objects, Matrices, Basic Concepts
@c    node-name, next, previous, up
@section Indexed objects

GiNaC allows you to handle expressions containing general indexed objects in
arbitrary spaces. It is also able to canonicalize and simplify such
expressions and perform symbolic dummy index summations. There are a number
of predefined indexed objects provided, like delta and metric tensors.

There are few restrictions placed on indexed objects and their indices and
it is easy to construct nonsense expressions, but our intention is to
provide a general framework that allows you to implement algorithms with
indexed quantities, getting in the way as little as possible.

@cindex @code{idx} (class)
@cindex @code{indexed} (class)
@subsection Indexed quantities and their indices

Indexed expressions in GiNaC are constructed of two special types of objects,
@dfn{index objects} and @dfn{indexed objects}.

@itemize @bullet

@cindex contravariant
@cindex covariant
@cindex variance
@item Index objects are of class @code{idx} or a subclass. Every index has
a @dfn{value} and a @dfn{dimension} (which is the dimension of the space
the index lives in) which can both be arbitrary expressions but are usually
a number or a simple symbol. In addition, indices of class @code{varidx} have
a @dfn{variance} (they can be co- or contravariant), and indices of class
@code{spinidx} have a variance and can be @dfn{dotted} or @dfn{undotted}.

@item Indexed objects are of class @code{indexed} or a subclass. They
contain a @dfn{base expression} (which is the expression being indexed), and
one or more indices.

@end itemize

@strong{Note:} when printing expressions, covariant indices and indices
without variance are denoted @samp{.i} while contravariant indices are
denoted @samp{~i}. Dotted indices have a @samp{*} in front of the index
value. In the following, we are going to use that notation in the text so
instead of @math{A^i_jk} we will write @samp{A~i.j.k}. Index dimensions are
not visible in the output.

A simple example shall illustrate the concepts:

@example
#include <iostream>
#include <ginac/ginac.h>
using namespace std;
using namespace GiNaC;

int main()
@{
    symbol i_sym("i"), j_sym("j");
    idx i(i_sym, 3), j(j_sym, 3);

    symbol A("A");
    cout << indexed(A, i, j) << endl;
     // -> A.i.j
    cout << index_dimensions << indexed(A, i, j) << endl;
     // -> A.i[3].j[3]
    cout << dflt; // reset cout to default output format (dimensions hidden)
    ...
@end example

The @code{idx} constructor takes two arguments, the index value and the
index dimension. First we define two index objects, @code{i} and @code{j},
both with the numeric dimension 3. The value of the index @code{i} is the
symbol @code{i_sym} (which prints as @samp{i}) and the value of the index
@code{j} is the symbol @code{j_sym} (which prints as @samp{j}). Next we
construct an expression containing one indexed object, @samp{A.i.j}. It has
the symbol @code{A} as its base expression and the two indices @code{i} and
@code{j}.

The dimensions of indices are normally not visible in the output, but one
can request them to be printed with the @code{index_dimensions} manipulator,
as shown above.

Note the difference between the indices @code{i} and @code{j} which are of
class @code{idx}, and the index values which are the symbols @code{i_sym}
and @code{j_sym}. The indices of indexed objects cannot directly be symbols
or numbers but must be index objects. For example, the following is not
correct and will raise an exception:

@example
symbol i("i"), j("j");
e = indexed(A, i, j); // ERROR: indices must be of type idx
@end example

You can have multiple indexed objects in an expression, index values can
be numeric, and index dimensions symbolic:

@example
    ...
    symbol B("B"), dim("dim");
    cout << 4 * indexed(A, i)
          + indexed(B, idx(j_sym, 4), idx(2, 3), idx(i_sym, dim)) << endl;
     // -> B.j.2.i+4*A.i
    ...
@end example

@code{B} has a 4-dimensional symbolic index @samp{k}, a 3-dimensional numeric
index of value 2, and a symbolic index @samp{i} with the symbolic dimension
@samp{dim}. Note that GiNaC doesn't automatically notify you that the free
indices of @samp{A} and @samp{B} in the sum don't match (you have to call
@code{simplify_indexed()} for that, see below).

In fact, base expressions, index values and index dimensions can be
arbitrary expressions:

@example
    ...
    cout << indexed(A+B, idx(2*i_sym+1, dim/2)) << endl;
     // -> (B+A).(1+2*i)
    ...
@end example

It's also possible to construct nonsense like @samp{Pi.sin(x)}. You will not
get an error message from this but you will probably not be able to do
anything useful with it.

@cindex @code{get_value()}
@cindex @code{get_dimension()}
The methods

@example
ex idx::get_value();
ex idx::get_dimension();
@end example

return the value and dimension of an @code{idx} object. If you have an index
in an expression, such as returned by calling @code{.op()} on an indexed
object, you can get a reference to the @code{idx} object with the function
@code{ex_to<idx>()} on the expression.

There are also the methods

@example
bool idx::is_numeric();
bool idx::is_symbolic();
bool idx::is_dim_numeric();
bool idx::is_dim_symbolic();
@end example

for checking whether the value and dimension are numeric or symbolic
(non-numeric). Using the @code{info()} method of an index (see @ref{Information
About Expressions}) returns information about the index value.

@cindex @code{varidx} (class)
If you need co- and contravariant indices, use the @code{varidx} class:

@example
    ...
    symbol mu_sym("mu"), nu_sym("nu");
    varidx mu(mu_sym, 4), nu(nu_sym, 4); // default is contravariant ~mu, ~nu
    varidx mu_co(mu_sym, 4, true);       // covariant index .mu

    cout << indexed(A, mu, nu) << endl;
     // -> A~mu~nu
    cout << indexed(A, mu_co, nu) << endl;
     // -> A.mu~nu
    cout << indexed(A, mu.toggle_variance(), nu) << endl;
     // -> A.mu~nu
    ...
@end example

A @code{varidx} is an @code{idx} with an additional flag that marks it as
co- or contravariant. The default is a contravariant (upper) index, but
this can be overridden by supplying a third argument to the @code{varidx}
constructor. The two methods

@example
bool varidx::is_covariant();
bool varidx::is_contravariant();
@end example

allow you to check the variance of a @code{varidx} object (use @code{ex_to<varidx>()}
to get the object reference from an expression). There's also the very useful
method

@example
ex varidx::toggle_variance();
@end example

which makes a new index with the same value and dimension but the opposite
variance. By using it you only have to define the index once.

@cindex @code{spinidx} (class)
The @code{spinidx} class provides dotted and undotted variant indices, as
used in the Weyl-van-der-Waerden spinor formalism:

@example
    ...
    symbol K("K"), C_sym("C"), D_sym("D");
    spinidx C(C_sym, 2), D(D_sym);          // default is 2-dimensional,
                                            // contravariant, undotted
    spinidx C_co(C_sym, 2, true);           // covariant index
    spinidx D_dot(D_sym, 2, false, true);   // contravariant, dotted
    spinidx D_co_dot(D_sym, 2, true, true); // covariant, dotted

    cout << indexed(K, C, D) << endl;
     // -> K~C~D
    cout << indexed(K, C_co, D_dot) << endl;
     // -> K.C~*D
    cout << indexed(K, D_co_dot, D) << endl;
     // -> K.*D~D
    ...
@end example

A @code{spinidx} is a @code{varidx} with an additional flag that marks it as
dotted or undotted. The default is undotted but this can be overridden by
supplying a fourth argument to the @code{spinidx} constructor. The two
methods

@example
bool spinidx::is_dotted();
bool spinidx::is_undotted();
@end example

allow you to check whether or not a @code{spinidx} object is dotted (use
@code{ex_to<spinidx>()} to get the object reference from an expression).
Finally, the two methods

@example
ex spinidx::toggle_dot();
ex spinidx::toggle_variance_dot();
@end example

create a new index with the same value and dimension but opposite dottedness
and the same or opposite variance.

@subsection Substituting indices

@cindex @code{subs()}
Sometimes you will want to substitute one symbolic index with another
symbolic or numeric index, for example when calculating one specific element
of a tensor expression. This is done with the @code{.subs()} method, as it
is done for symbols (see @ref{Substituting Expressions}).

You have two possibilities here. You can either substitute the whole index
by another index or expression:

@example
    ...
    ex e = indexed(A, mu_co);
    cout << e << " becomes " << e.subs(mu_co == nu) << endl;
     // -> A.mu becomes A~nu
    cout << e << " becomes " << e.subs(mu_co == varidx(0, 4)) << endl;
     // -> A.mu becomes A~0
    cout << e << " becomes " << e.subs(mu_co == 0) << endl;
     // -> A.mu becomes A.0
    ...
@end example

The third example shows that trying to replace an index with something that
is not an index will substitute the index value instead.

Alternatively, you can substitute the @emph{symbol} of a symbolic index by
another expression:

@example
    ...
    ex e = indexed(A, mu_co);
    cout << e << " becomes " << e.subs(mu_sym == nu_sym) << endl;
     // -> A.mu becomes A.nu
    cout << e << " becomes " << e.subs(mu_sym == 0) << endl;
     // -> A.mu becomes A.0
    ...
@end example

As you see, with the second method only the value of the index will get
substituted. Its other properties, including its dimension, remain unchanged.
If you want to change the dimension of an index you have to substitute the
whole index by another one with the new dimension.

Finally, substituting the base expression of an indexed object works as
expected:

@example
    ...
    ex e = indexed(A, mu_co);
    cout << e << " becomes " << e.subs(A == A+B) << endl;
     // -> A.mu becomes (B+A).mu
    ...
@end example

@subsection Symmetries
@cindex @code{symmetry} (class)
@cindex @code{sy_none()}
@cindex @code{sy_symm()}
@cindex @code{sy_anti()}
@cindex @code{sy_cycl()}

Indexed objects can have certain symmetry properties with respect to their
indices. Symmetries are specified as a tree of objects of class @code{symmetry}
that is constructed with the helper functions

@example
symmetry sy_none(...);
symmetry sy_symm(...);
symmetry sy_anti(...);
symmetry sy_cycl(...);
@end example

@code{sy_none()} stands for no symmetry, @code{sy_symm()} and @code{sy_anti()}
specify fully symmetric or antisymmetric, respectively, and @code{sy_cycl()}
represents a cyclic symmetry. Each of these functions accepts up to four
arguments which can be either symmetry objects themselves or unsigned integer
numbers that represent an index position (counting from 0). A symmetry
specification that consists of only a single @code{sy_symm()}, @code{sy_anti()}
or @code{sy_cycl()} with no arguments specifies the respective symmetry for
all indices.

Here are some examples of symmetry definitions:

@example
    ...
    // No symmetry:
    e = indexed(A, i, j);
    e = indexed(A, sy_none(), i, j);     // equivalent
    e = indexed(A, sy_none(0, 1), i, j); // equivalent

    // Symmetric in all three indices:
    e = indexed(A, sy_symm(), i, j, k);
    e = indexed(A, sy_symm(0, 1, 2), i, j, k); // equivalent
    e = indexed(A, sy_symm(2, 0, 1), i, j, k); // same symmetry, but yields a
                                               // different canonical order

    // Symmetric in the first two indices only:
    e = indexed(A, sy_symm(0, 1), i, j, k);
    e = indexed(A, sy_none(sy_symm(0, 1), 2), i, j, k); // equivalent

    // Antisymmetric in the first and last index only (index ranges need not
    // be contiguous):
    e = indexed(A, sy_anti(0, 2), i, j, k);
    e = indexed(A, sy_none(sy_anti(0, 2), 1), i, j, k); // equivalent

    // An example of a mixed symmetry: antisymmetric in the first two and
    // last two indices, symmetric when swapping the first and last index
    // pairs (like the Riemann curvature tensor):
    e = indexed(A, sy_symm(sy_anti(0, 1), sy_anti(2, 3)), i, j, k, l);

    // Cyclic symmetry in all three indices:
    e = indexed(A, sy_cycl(), i, j, k);
    e = indexed(A, sy_cycl(0, 1, 2), i, j, k); // equivalent

    // The following examples are invalid constructions that will throw
    // an exception at run time.

    // An index may not appear multiple times:
    e = indexed(A, sy_symm(0, 0, 1), i, j, k); // ERROR
    e = indexed(A, sy_none(sy_symm(0, 1), sy_anti(0, 2)), i, j, k); // ERROR

    // Every child of sy_symm(), sy_anti() and sy_cycl() must refer to the
    // same number of indices:
    e = indexed(A, sy_symm(sy_anti(0, 1), 2), i, j, k); // ERROR

    // And of course, you cannot specify indices which are not there:
    e = indexed(A, sy_symm(0, 1, 2, 3), i, j, k); // ERROR
    ...
@end example

If you need to specify more than four indices, you have to use the
@code{.add()} method of the @code{symmetry} class. For example, to specify
full symmetry in the first six indices you would write
@code{sy_symm(0, 1, 2, 3).add(4).add(5)}.

If an indexed object has a symmetry, GiNaC will automatically bring the
indices into a canonical order which allows for some immediate simplifications:

@example
    ...
    cout << indexed(A, sy_symm(), i, j)
          + indexed(A, sy_symm(), j, i) << endl;
     // -> 2*A.j.i
    cout << indexed(B, sy_anti(), i, j)
          + indexed(B, sy_anti(), j, i) << endl;
     // -> 0
    cout << indexed(B, sy_anti(), i, j, k)
          - indexed(B, sy_anti(), j, k, i) << endl;
     // -> 0
    ...
@end example

@cindex @code{get_free_indices()}
@cindex dummy index
@subsection Dummy indices

GiNaC treats certain symbolic index pairs as @dfn{dummy indices} meaning
that a summation over the index range is implied. Symbolic indices which are
not dummy indices are called @dfn{free indices}. Numeric indices are neither
dummy nor free indices.

To be recognized as a dummy index pair, the two indices must be of the same
class and their value must be the same single symbol (an index like
@samp{2*n+1} is never a dummy index). If the indices are of class
@code{varidx} they must also be of opposite variance; if they are of class
@code{spinidx} they must be both dotted or both undotted.

The method @code{.get_free_indices()} returns a vector containing the free
indices of an expression. It also checks that the free indices of the terms
of a sum are consistent:

@example
@{
    symbol A("A"), B("B"), C("C");

    symbol i_sym("i"), j_sym("j"), k_sym("k"), l_sym("l");
    idx i(i_sym, 3), j(j_sym, 3), k(k_sym, 3), l(l_sym, 3);

    ex e = indexed(A, i, j) * indexed(B, j, k) + indexed(C, k, l, i, l);
    cout << exprseq(e.get_free_indices()) << endl;
     // -> (.i,.k)
     // 'j' and 'l' are dummy indices

    symbol mu_sym("mu"), nu_sym("nu"), rho_sym("rho"), sigma_sym("sigma");
    varidx mu(mu_sym, 4), nu(nu_sym, 4), rho(rho_sym, 4), sigma(sigma_sym, 4);

    e = indexed(A, mu, nu) * indexed(B, nu.toggle_variance(), rho)
      + indexed(C, mu, sigma, rho, sigma.toggle_variance());
    cout << exprseq(e.get_free_indices()) << endl;
     // -> (~mu,~rho)
     // 'nu' is a dummy index, but 'sigma' is not

    e = indexed(A, mu, mu);
    cout << exprseq(e.get_free_indices()) << endl;
     // -> (~mu)
     // 'mu' is not a dummy index because it appears twice with the same
     // variance

    e = indexed(A, mu, nu) + 42;
    cout << exprseq(e.get_free_indices()) << endl; // ERROR
     // this will throw an exception:
     // "add::get_free_indices: inconsistent indices in sum"
@}
@end example

@cindex @code{simplify_indexed()}
@subsection Simplifying indexed expressions

In addition to the few automatic simplifications that GiNaC performs on
indexed expressions (such as re-ordering the indices of symmetric tensors
and calculating traces and convolutions of matrices and predefined tensors)
there is the method

@example
ex ex::simplify_indexed();
ex ex::simplify_indexed(const scalar_products & sp);
@end example

that performs some more expensive operations:

@itemize
@item it checks the consistency of free indices in sums in the same way
  @code{get_free_indices()} does
@item it tries to give dummy indices that appear in different terms of a sum
  the same name to allow simplifications like @math{a_i*b_i-a_j*b_j=0}
@item it (symbolically) calculates all possible dummy index summations/contractions
  with the predefined tensors (this will be explained in more detail in the
  next section)
@item it detects contractions that vanish for symmetry reasons, for example
  the contraction of a symmetric and a totally antisymmetric tensor
@item as a special case of dummy index summation, it can replace scalar products
  of two tensors with a user-defined value
@end itemize

The last point is done with the help of the @code{scalar_products} class
which is used to store scalar products with known values (this is not an
arithmetic class, you just pass it to @code{simplify_indexed()}):

@example
@{
    symbol A("A"), B("B"), C("C"), i_sym("i");
    idx i(i_sym, 3);

    scalar_products sp;
    sp.add(A, B, 0); // A and B are orthogonal
    sp.add(A, C, 0); // A and C are orthogonal
    sp.add(A, A, 4); // A^2 = 4 (A has length 2)

    e = indexed(A + B, i) * indexed(A + C, i);
    cout << e << endl;
     // -> (B+A).i*(A+C).i

    cout << e.expand(expand_options::expand_indexed).simplify_indexed(sp)
         << endl;
     // -> 4+C.i*B.i
@}
@end example

The @code{scalar_products} object @code{sp} acts as a storage for the
scalar products added to it with the @code{.add()} method. This method
takes three arguments: the two expressions of which the scalar product is
taken, and the expression to replace it with. After @code{sp.add(A, B, 0)},
@code{simplify_indexed()} will replace all scalar products of indexed
objects that have the symbols @code{A} and @code{B} as base expressions
with the single value 0. The number, type and dimension of the indices
don't matter; @samp{A~mu~nu*B.mu.nu} would also be replaced by 0.

@cindex @code{expand()}
The example above also illustrates a feature of the @code{expand()} method:
if passed the @code{expand_indexed} option it will distribute indices
over sums, so @samp{(A+B).i} becomes @samp{A.i+B.i}.

@cindex @code{tensor} (class)
@subsection Predefined tensors

Some frequently used special tensors such as the delta, epsilon and metric
tensors are predefined in GiNaC. They have special properties when
contracted with other tensor expressions and some of them have constant
matrix representations (they will evaluate to a number when numeric
indices are specified).

@cindex @code{delta_tensor()}
@subsubsection Delta tensor

The delta tensor takes two indices, is symmetric and has the matrix
representation @code{diag(1, 1, 1, ...)}. It is constructed by the function
@code{delta_tensor()}:

@example
@{
    symbol A("A"), B("B");

    idx i(symbol("i"), 3), j(symbol("j"), 3),
        k(symbol("k"), 3), l(symbol("l"), 3);

    ex e = indexed(A, i, j) * indexed(B, k, l)
         * delta_tensor(i, k) * delta_tensor(j, l) << endl;
    cout << e.simplify_indexed() << endl;
     // -> B.i.j*A.i.j

    cout << delta_tensor(i, i) << endl;
     // -> 3
@}
@end example

@cindex @code{metric_tensor()}
@subsubsection General metric tensor

The function @code{metric_tensor()} creates a general symmetric metric
tensor with two indices that can be used to raise/lower tensor indices. The
metric tensor is denoted as @samp{g} in the output and if its indices are of
mixed variance it is automatically replaced by a delta tensor:

@example
@{
    symbol A("A");

    varidx mu(symbol("mu"), 4), nu(symbol("nu"), 4), rho(symbol("rho"), 4);

    ex e = metric_tensor(mu, nu) * indexed(A, nu.toggle_variance(), rho);
    cout << e.simplify_indexed() << endl;
     // -> A~mu~rho

    e = delta_tensor(mu, nu.toggle_variance()) * metric_tensor(nu, rho);
    cout << e.simplify_indexed() << endl;
     // -> g~mu~rho

    e = metric_tensor(mu.toggle_variance(), nu.toggle_variance())
      * metric_tensor(nu, rho);
    cout << e.simplify_indexed() << endl;
     // -> delta.mu~rho

    e = metric_tensor(nu.toggle_variance(), rho.toggle_variance())
      * metric_tensor(mu, nu) * (delta_tensor(mu.toggle_variance(), rho)
        + indexed(A, mu.toggle_variance(), rho));
    cout << e.simplify_indexed() << endl;
     // -> 4+A.rho~rho
@}
@end example

@cindex @code{lorentz_g()}
@subsubsection Minkowski metric tensor

The Minkowski metric tensor is a special metric tensor with a constant
matrix representation which is either @code{diag(1, -1, -1, ...)} (negative
signature, the default) or @code{diag(-1, 1, 1, ...)} (positive signature).
It is created with the function @code{lorentz_g()} (although it is output as
@samp{eta}):

@example
@{
    varidx mu(symbol("mu"), 4);

    e = delta_tensor(varidx(0, 4), mu.toggle_variance())
      * lorentz_g(mu, varidx(0, 4));       // negative signature
    cout << e.simplify_indexed() << endl;
     // -> 1

    e = delta_tensor(varidx(0, 4), mu.toggle_variance())
      * lorentz_g(mu, varidx(0, 4), true); // positive signature
    cout << e.simplify_indexed() << endl;
     // -> -1
@}
@end example

@cindex @code{spinor_metric()}
@subsubsection Spinor metric tensor

The function @code{spinor_metric()} creates an antisymmetric tensor with
two indices that is used to raise/lower indices of 2-component spinors.
It is output as @samp{eps}:

@example
@{
    symbol psi("psi");

    spinidx A(symbol("A")), B(symbol("B")), C(symbol("C"));
    ex A_co = A.toggle_variance(), B_co = B.toggle_variance();

    e = spinor_metric(A, B) * indexed(psi, B_co);
    cout << e.simplify_indexed() << endl;
     // -> psi~A

    e = spinor_metric(A, B) * indexed(psi, A_co);
    cout << e.simplify_indexed() << endl;
     // -> -psi~B

    e = spinor_metric(A_co, B_co) * indexed(psi, B);
    cout << e.simplify_indexed() << endl;
     // -> -psi.A

    e = spinor_metric(A_co, B_co) * indexed(psi, A);
    cout << e.simplify_indexed() << endl;
     // -> psi.B

    e = spinor_metric(A_co, B_co) * spinor_metric(A, B);
    cout << e.simplify_indexed() << endl;
     // -> 2

    e = spinor_metric(A_co, B_co) * spinor_metric(B, C);
    cout << e.simplify_indexed() << endl;
     // -> -delta.A~C
@}
@end example

The matrix representation of the spinor metric is @code{[[0, 1], [-1, 0]]}.

@cindex @code{epsilon_tensor()}
@cindex @code{lorentz_eps()}
@subsubsection Epsilon tensor

The epsilon tensor is totally antisymmetric, its number of indices is equal
to the dimension of the index space (the indices must all be of the same
numeric dimension), and @samp{eps.1.2.3...} (resp. @samp{eps~0~1~2...}) is
defined to be 1. Its behavior with indices that have a variance also
depends on the signature of the metric. Epsilon tensors are output as
@samp{eps}.

There are three functions defined to create epsilon tensors in 2, 3 and 4
dimensions:

@example
ex epsilon_tensor(const ex & i1, const ex & i2);
ex epsilon_tensor(const ex & i1, const ex & i2, const ex & i3);
ex lorentz_eps(const ex & i1, const ex & i2, const ex & i3, const ex & i4, bool pos_sig = false);
@end example

The first two functions create an epsilon tensor in 2 or 3 Euclidean
dimensions, the last function creates an epsilon tensor in a 4-dimensional
Minkowski space (the last @code{bool} argument specifies whether the metric
has negative or positive signature, as in the case of the Minkowski metric
tensor):

@example
@{
    varidx mu(symbol("mu"), 4), nu(symbol("nu"), 4), rho(symbol("rho"), 4),
           sig(symbol("sig"), 4), lam(symbol("lam"), 4), bet(symbol("bet"), 4);
    e = lorentz_eps(mu, nu, rho, sig) *
        lorentz_eps(mu.toggle_variance(), nu.toggle_variance(), lam, bet);
    cout << simplify_indexed(e) << endl;
     // -> 2*eta~bet~rho*eta~sig~lam-2*eta~sig~bet*eta~rho~lam

    idx i(symbol("i"), 3), j(symbol("j"), 3), k(symbol("k"), 3);
    symbol A("A"), B("B");
    e = epsilon_tensor(i, j, k) * indexed(A, j) * indexed(B, k);
    cout << simplify_indexed(e) << endl;
     // -> -B.k*A.j*eps.i.k.j
    e = epsilon_tensor(i, j, k) * indexed(A, j) * indexed(A, k);
    cout << simplify_indexed(e) << endl;
     // -> 0
@}
@end example

@subsection Linear algebra

The @code{matrix} class can be used with indices to do some simple linear
algebra (linear combinations and products of vectors and matrices, traces
and scalar products):

@example
@{
    idx i(symbol("i"), 2), j(symbol("j"), 2);
    symbol x("x"), y("y");

    // A is a 2x2 matrix, X is a 2x1 vector
    matrix A(2, 2), X(2, 1);
    A = 1, 2,
        3, 4;
    X = x, y;

    cout << indexed(A, i, i) << endl;
     // -> 5

    ex e = indexed(A, i, j) * indexed(X, j);
    cout << e.simplify_indexed() << endl;
     // -> [[2*y+x],[4*y+3*x]].i

    e = indexed(A, i, j) * indexed(X, i) + indexed(X, j) * 2;
    cout << e.simplify_indexed() << endl;
     // -> [[3*y+3*x,6*y+2*x]].j
@}
@end example

You can of course obtain the same results with the @code{matrix::add()},
@code{matrix::mul()} and @code{matrix::trace()} methods (@pxref{Matrices})
but with indices you don't have to worry about transposing matrices.

Matrix indices always start at 0 and their dimension must match the number
of rows/columns of the matrix. Matrices with one row or one column are
vectors and can have one or two indices (it doesn't matter whether it's a
row or a column vector). Other matrices must have two indices.

You should be careful when using indices with variance on matrices. GiNaC
doesn't look at the variance and doesn't know that @samp{F~mu~nu} and
@samp{F.mu.nu} are different matrices. In this case you should use only
one form for @samp{F} and explicitly multiply it with a matrix representation
of the metric tensor.


@node Non-commutative objects, Hash Maps, Indexed objects, Basic Concepts
@c    node-name, next, previous, up
@section Non-commutative objects

GiNaC is equipped to handle certain non-commutative algebras. Three classes of
non-commutative objects are built-in which are mostly of use in high energy
physics:

@itemize
@item Clifford (Dirac) algebra (class @code{clifford})
@item su(3) Lie algebra (class @code{color})
@item Matrices (unindexed) (class @code{matrix})
@end itemize

The @code{clifford} and @code{color} classes are subclasses of
@code{indexed} because the elements of these algebras usually carry
indices. The @code{matrix} class is described in more detail in
@ref{Matrices}.

Unlike most computer algebra systems, GiNaC does not primarily provide an
operator (often denoted @samp{&*}) for representing inert products of
arbitrary objects. Rather, non-commutativity in GiNaC is a property of the
classes of objects involved, and non-commutative products are formed with
the usual @samp{*} operator, as are ordinary products. GiNaC is capable of
figuring out by itself which objects commutate and will group the factors
by their class. Consider this example:

@example
    ...
    varidx mu(symbol("mu"), 4), nu(symbol("nu"), 4);
    idx a(symbol("a"), 8), b(symbol("b"), 8);
    ex e = -dirac_gamma(mu) * (2*color_T(a)) * 8 * color_T(b) * dirac_gamma(nu);
    cout << e << endl;
     // -> -16*(gamma~mu*gamma~nu)*(T.a*T.b)
    ...
@end example

As can be seen, GiNaC pulls out the overall commutative factor @samp{-16} and
groups the non-commutative factors (the gammas and the su(3) generators)
together while preserving the order of factors within each class (because
Clifford objects commutate with color objects). The resulting expression is a
@emph{commutative} product with two factors that are themselves non-commutative
products (@samp{gamma~mu*gamma~nu} and @samp{T.a*T.b}). For clarification,
parentheses are placed around the non-commutative products in the output.

@cindex @code{ncmul} (class)
Non-commutative products are internally represented by objects of the class
@code{ncmul}, as opposed to commutative products which are handled by the
@code{mul} class. You will normally not have to worry about this distinction,
though.

The advantage of this approach is that you never have to worry about using
(or forgetting to use) a special operator when constructing non-commutative
expressions. Also, non-commutative products in GiNaC are more intelligent
than in other computer algebra systems; they can, for example, automatically
canonicalize themselves according to rules specified in the implementation
of the non-commutative classes. The drawback is that to work with other than
the built-in algebras you have to implement new classes yourself. Symbols
always commutate and it's not possible to construct non-commutative products
using symbols to represent the algebra elements or generators. User-defined
functions can, however, be specified as being non-commutative.

@cindex @code{return_type()}
@cindex @code{return_type_tinfo()}
Information about the commutativity of an object or expression can be
obtained with the two member functions

@example
unsigned ex::return_type() const;
unsigned ex::return_type_tinfo() const;
@end example

The @code{return_type()} function returns one of three values (defined in
the header file @file{flags.h}), corresponding to three categories of
expressions in GiNaC:

@itemize
@item @code{return_types::commutative}: Commutates with everything. Most GiNaC
  classes are of this kind.
@item @code{return_types::noncommutative}: Non-commutative, belonging to a
  certain class of non-commutative objects which can be determined with the
  @code{return_type_tinfo()} method. Expressions of this category commutate
  with everything except @code{noncommutative} expressions of the same
  class.
@item @code{return_types::noncommutative_composite}: Non-commutative, composed
  of non-commutative objects of different classes. Expressions of this
  category don't commutate with any other @code{noncommutative} or
  @code{noncommutative_composite} expressions.
@end itemize

The value returned by the @code{return_type_tinfo()} method is valid only
when the return type of the expression is @code{noncommutative}. It is a
value that is unique to the class of the object and usually one of the
constants in @file{tinfos.h}, or derived therefrom.

Here are a couple of examples:

@cartouche
@multitable @columnfractions 0.33 0.33 0.34
@item @strong{Expression} @tab @strong{@code{return_type()}} @tab @strong{@code{return_type_tinfo()}}
@item @code{42} @tab @code{commutative} @tab -
@item @code{2*x-y} @tab @code{commutative} @tab -
@item @code{dirac_ONE()} @tab @code{noncommutative} @tab @code{TINFO_clifford}
@item @code{dirac_gamma(mu)*dirac_gamma(nu)} @tab @code{noncommutative} @tab @code{TINFO_clifford}
@item @code{2*color_T(a)} @tab @code{noncommutative} @tab @code{TINFO_color}
@item @code{dirac_ONE()*color_T(a)} @tab @code{noncommutative_composite} @tab -
@end multitable
@end cartouche

Note: the @code{return_type_tinfo()} of Clifford objects is only equal to
@code{TINFO_clifford} for objects with a representation label of zero.
Other representation labels yield a different @code{return_type_tinfo()},
but it's the same for any two objects with the same label. This is also true
for color objects.

A last note: With the exception of matrices, positive integer powers of
non-commutative objects are automatically expanded in GiNaC. For example,
@code{pow(a*b, 2)} becomes @samp{a*b*a*b} if @samp{a} and @samp{b} are
non-commutative expressions).


@cindex @code{clifford} (class)
@subsection Clifford algebra

@cindex @code{dirac_gamma()}
Clifford algebra elements (also called Dirac gamma matrices, although GiNaC
doesn't treat them as matrices) are designated as @samp{gamma~mu} and satisfy
@samp{gamma~mu*gamma~nu + gamma~nu*gamma~mu = 2*eta~mu~nu} where @samp{eta~mu~nu}
is the Minkowski metric tensor. Dirac gammas are constructed by the function

@example
ex dirac_gamma(const ex & mu, unsigned char rl = 0);
@end example

which takes two arguments: the index and a @dfn{representation label} in the
range 0 to 255 which is used to distinguish elements of different Clifford
algebras (this is also called a @dfn{spin line index}). Gammas with different
labels commutate with each other. The dimension of the index can be 4 or (in
the framework of dimensional regularization) any symbolic value. Spinor
indices on Dirac gammas are not supported in GiNaC.

@cindex @code{dirac_ONE()}
The unity element of a Clifford algebra is constructed by

@example
ex dirac_ONE(unsigned char rl = 0);
@end example

@strong{Note:} You must always use @code{dirac_ONE()} when referring to
multiples of the unity element, even though it's customary to omit it.
E.g. instead of @code{dirac_gamma(mu)*(dirac_slash(q,4)+m)} you have to
write @code{dirac_gamma(mu)*(dirac_slash(q,4)+m*dirac_ONE())}. Otherwise,
GiNaC will complain and/or produce incorrect results.

@cindex @code{dirac_gamma5()}
There is a special element @samp{gamma5} that commutates with all other
gammas, has a unit square, and in 4 dimensions equals
@samp{gamma~0 gamma~1 gamma~2 gamma~3}, provided by

@example
ex dirac_gamma5(unsigned char rl = 0);
@end example

@cindex @code{dirac_gammaL()}
@cindex @code{dirac_gammaR()}
The chiral projectors @samp{(1+/-gamma5)/2} are also available as proper
objects, constructed by

@example
ex dirac_gammaL(unsigned char rl = 0);
ex dirac_gammaR(unsigned char rl = 0);
@end example

They observe the relations @samp{gammaL^2 = gammaL}, @samp{gammaR^2 = gammaR},
and @samp{gammaL gammaR = gammaR gammaL = 0}.

@cindex @code{dirac_slash()}
Finally, the function

@example
ex dirac_slash(const ex & e, const ex & dim, unsigned char rl = 0);
@end example

creates a term that represents a contraction of @samp{e} with the Dirac
Lorentz vector (it behaves like a term of the form @samp{e.mu gamma~mu}
with a unique index whose dimension is given by the @code{dim} argument).
Such slashed expressions are printed with a trailing backslash, e.g. @samp{e\}.

In products of dirac gammas, superfluous unity elements are automatically
removed, squares are replaced by their values, and @samp{gamma5}, @samp{gammaL}
and @samp{gammaR} are moved to the front.

The @code{simplify_indexed()} function performs contractions in gamma strings,
for example

@example
@{
    ...
    symbol a("a"), b("b"), D("D");
    varidx mu(symbol("mu"), D);
    ex e = dirac_gamma(mu) * dirac_slash(a, D)
         * dirac_gamma(mu.toggle_variance());
    cout << e << endl;
     // -> gamma~mu*a\*gamma.mu
    e = e.simplify_indexed();
    cout << e << endl;
     // -> -D*a\+2*a\
    cout << e.subs(D == 4) << endl;
     // -> -2*a\
    ...
@}
@end example

@cindex @code{dirac_trace()}
To calculate the trace of an expression containing strings of Dirac gammas
you use the function

@example
ex dirac_trace(const ex & e, unsigned char rl = 0, const ex & trONE = 4);
@end example

This function takes the trace of all gammas with the specified representation
label; gammas with other labels are left standing. The last argument to
@code{dirac_trace()} is the value to be returned for the trace of the unity
element, which defaults to 4. The @code{dirac_trace()} function is a linear
functional that is equal to the usual trace only in @math{D = 4} dimensions.
In particular, the functional is not cyclic in @math{D != 4} dimensions when
acting on expressions containing @samp{gamma5}, so it's not a proper trace.
This @samp{gamma5} scheme is described in greater detail in
@cite{The Role of gamma5 in Dimensional Regularization}.

The value of the trace itself is also usually different in 4 and in
@math{D != 4} dimensions:

@example
@{
    // 4 dimensions
    varidx mu(symbol("mu"), 4), nu(symbol("nu"), 4), rho(symbol("rho"), 4);
    ex e = dirac_gamma(mu) * dirac_gamma(nu) *
           dirac_gamma(mu.toggle_variance()) * dirac_gamma(rho);
    cout << dirac_trace(e).simplify_indexed() << endl;
     // -> -8*eta~rho~nu
@}
...
@{
    // D dimensions
    symbol D("D");
    varidx mu(symbol("mu"), D), nu(symbol("nu"), D), rho(symbol("rho"), D);
    ex e = dirac_gamma(mu) * dirac_gamma(nu) *
           dirac_gamma(mu.toggle_variance()) * dirac_gamma(rho);
    cout << dirac_trace(e).simplify_indexed() << endl;
     // -> 8*eta~rho~nu-4*eta~rho~nu*D
@}
@end example

Here is an example for using @code{dirac_trace()} to compute a value that
appears in the calculation of the one-loop vacuum polarization amplitude in
QED:

@example
@{
    symbol q("q"), l("l"), m("m"), ldotq("ldotq"), D("D");
    varidx mu(symbol("mu"), D), nu(symbol("nu"), D);

    scalar_products sp;
    sp.add(l, l, pow(l, 2));
    sp.add(l, q, ldotq);

    ex e = dirac_gamma(mu) *
           (dirac_slash(l, D) + dirac_slash(q, D) + m * dirac_ONE()) *    
           dirac_gamma(mu.toggle_variance()) *
           (dirac_slash(l, D) + m * dirac_ONE());   
    e = dirac_trace(e).simplify_indexed(sp);
    e = e.collect(lst(l, ldotq, m));
    cout << e << endl;
     // -> (8-4*D)*l^2+(8-4*D)*ldotq+4*D*m^2
@}
@end example

The @code{canonicalize_clifford()} function reorders all gamma products that
appear in an expression to a canonical (but not necessarily simple) form.
You can use this to compare two expressions or for further simplifications:

@example
@{
    varidx mu(symbol("mu"), 4), nu(symbol("nu"), 4);
    ex e = dirac_gamma(mu) * dirac_gamma(nu) + dirac_gamma(nu) * dirac_gamma(mu);
    cout << e << endl;
     // -> gamma~mu*gamma~nu+gamma~nu*gamma~mu

    e = canonicalize_clifford(e);
    cout << e << endl;
     // -> 2*ONE*eta~mu~nu
@}
@end example


@cindex @code{color} (class)
@subsection Color algebra

@cindex @code{color_T()}
For computations in quantum chromodynamics, GiNaC implements the base elements
and structure constants of the su(3) Lie algebra (color algebra). The base
elements @math{T_a} are constructed by the function

@example
ex color_T(const ex & a, unsigned char rl = 0);
@end example

which takes two arguments: the index and a @dfn{representation label} in the
range 0 to 255 which is used to distinguish elements of different color
algebras. Objects with different labels commutate with each other. The
dimension of the index must be exactly 8 and it should be of class @code{idx},
not @code{varidx}.

@cindex @code{color_ONE()}
The unity element of a color algebra is constructed by

@example
ex color_ONE(unsigned char rl = 0);
@end example

@strong{Note:} You must always use @code{color_ONE()} when referring to
multiples of the unity element, even though it's customary to omit it.
E.g. instead of @code{color_T(a)*(color_T(b)*indexed(X,b)+1)} you have to
write @code{color_T(a)*(color_T(b)*indexed(X,b)+color_ONE())}. Otherwise,
GiNaC may produce incorrect results.

@cindex @code{color_d()}
@cindex @code{color_f()}
The functions

@example
ex color_d(const ex & a, const ex & b, const ex & c);
ex color_f(const ex & a, const ex & b, const ex & c);
@end example

create the symmetric and antisymmetric structure constants @math{d_abc} and
@math{f_abc} which satisfy @math{@{T_a, T_b@} = 1/3 delta_ab + d_abc T_c}
and @math{[T_a, T_b] = i f_abc T_c}.

@cindex @code{color_h()}
There's an additional function

@example
ex color_h(const ex & a, const ex & b, const ex & c);
@end example

which returns the linear combination @samp{color_d(a, b, c)+I*color_f(a, b, c)}.

The function @code{simplify_indexed()} performs some simplifications on
expressions containing color objects:

@example
@{
    ...
    idx a(symbol("a"), 8), b(symbol("b"), 8), c(symbol("c"), 8),
        k(symbol("k"), 8), l(symbol("l"), 8);

    e = color_d(a, b, l) * color_f(a, b, k);
    cout << e.simplify_indexed() << endl;
     // -> 0

    e = color_d(a, b, l) * color_d(a, b, k);
    cout << e.simplify_indexed() << endl;
     // -> 5/3*delta.k.l

    e = color_f(l, a, b) * color_f(a, b, k);
    cout << e.simplify_indexed() << endl;
     // -> 3*delta.k.l

    e = color_h(a, b, c) * color_h(a, b, c);
    cout << e.simplify_indexed() << endl;
     // -> -32/3

    e = color_h(a, b, c) * color_T(b) * color_T(c);
    cout << e.simplify_indexed() << endl;
     // -> -2/3*T.a

    e = color_h(a, b, c) * color_T(a) * color_T(b) * color_T(c);
    cout << e.simplify_indexed() << endl;
     // -> -8/9*ONE

    e = color_T(k) * color_T(a) * color_T(b) * color_T(k);
    cout << e.simplify_indexed() << endl;
     // -> 1/4*delta.b.a*ONE-1/6*T.a*T.b
    ...
@end example

@cindex @code{color_trace()}
To calculate the trace of an expression containing color objects you use the
function

@example
ex color_trace(const ex & e, unsigned char rl = 0);
@end example

This function takes the trace of all color @samp{T} objects with the
specified representation label; @samp{T}s with other labels are left
standing. For example:

@example
    ...
    e = color_trace(4 * color_T(a) * color_T(b) * color_T(c));
    cout << e << endl;
     // -> -I*f.a.c.b+d.a.c.b
@}
@end example


@node Hash Maps, Methods and Functions, Non-commutative objects, Basic Concepts
@c    node-name, next, previous, up
@section Hash Maps
@cindex hash maps
@cindex @code{exhashmap} (class)

For your convenience, GiNaC offers the container template @code{exhashmap<T>}
that can be used as a drop-in replacement for the STL
@code{std::map<ex, T, ex_is_less>}, using hash tables to provide faster,
typically constant-time, element look-up than @code{map<>}.

@code{exhashmap<>} supports all @code{map<>} members and operations, with the
following differences:

@itemize @bullet
@item
no @code{lower_bound()} and @code{upper_bound()} methods
@item
no reverse iterators, no @code{rbegin()}/@code{rend()}
@item 
no @code{operator<(exhashmap, exhashmap)}
@item
the comparison function object @code{key_compare} is hardcoded to
@code{ex_is_less}
@item
the constructor @code{exhashmap(size_t n)} allows specifying the minimum
initial hash table size (the actual table size after construction may be
larger than the specified value)
@item
the method @code{size_t bucket_count()} returns the current size of the hash
table
@item 
@code{insert()} and @code{erase()} operations invalidate all iterators
@end itemize


@node Methods and Functions, Information About Expressions, Hash Maps, Top
@c    node-name, next, previous, up
@chapter Methods and Functions
@cindex polynomial

In this chapter the most important algorithms provided by GiNaC will be
described.  Some of them are implemented as functions on expressions,
others are implemented as methods provided by expression objects.  If
they are methods, there exists a wrapper function around it, so you can
alternatively call it in a functional way as shown in the simple
example:

@example
    ...
    cout << "As method:   " << sin(1).evalf() << endl;
    cout << "As function: " << evalf(sin(1)) << endl;
    ...
@end example

@cindex @code{subs()}
The general rule is that wherever methods accept one or more parameters
(@var{arg1}, @var{arg2}, @dots{}) the order of arguments the function
wrapper accepts is the same but preceded by the object to act on
(@var{object}, @var{arg1}, @var{arg2}, @dots{}).  This approach is the
most natural one in an OO model but it may lead to confusion for MapleV
users because where they would type @code{A:=x+1; subs(x=2,A);} GiNaC
would require @code{A=x+1; subs(A,x==2);} (after proper declaration of
@code{A} and @code{x}).  On the other hand, since MapleV returns 3 on
@code{A:=x^2+3; coeff(A,x,0);} (GiNaC: @code{A=pow(x,2)+3;
coeff(A,x,0);}) it is clear that MapleV is not trying to be consistent
here.  Also, users of MuPAD will in most cases feel more comfortable
with GiNaC's convention.  All function wrappers are implemented
as simple inline functions which just call the corresponding method and
are only provided for users uncomfortable with OO who are dead set to
avoid method invocations.  Generally, nested function wrappers are much
harder to read than a sequence of methods and should therefore be
avoided if possible.  On the other hand, not everything in GiNaC is a
method on class @code{ex} and sometimes calling a function cannot be
avoided.

@menu
* Information About Expressions::
* Numerical Evaluation::
* Substituting Expressions::
* Pattern Matching and Advanced Substitutions::
* Applying a Function on Subexpressions::
* Visitors and Tree Traversal::
* Polynomial Arithmetic::           Working with polynomials.
* Rational Expressions::            Working with rational functions.
* Symbolic Differentiation::
* Series Expansion::                Taylor and Laurent expansion.
* Symmetrization::
* Built-in Functions::              List of predefined mathematical functions.
* Multiple polylogarithms::
* Complex Conjugation::
* Built-in Functions::              List of predefined mathematical functions.
* Solving Linear Systems of Equations::
* Input/Output::                    Input and output of expressions.
@end menu


@node Information About Expressions, Numerical Evaluation, Methods and Functions, Methods and Functions
@c    node-name, next, previous, up
@section Getting information about expressions

@subsection Checking expression types
@cindex @code{is_a<@dots{}>()}
@cindex @code{is_exactly_a<@dots{}>()}
@cindex @code{ex_to<@dots{}>()}
@cindex Converting @code{ex} to other classes
@cindex @code{info()}
@cindex @code{return_type()}
@cindex @code{return_type_tinfo()}

Sometimes it's useful to check whether a given expression is a plain number,
a sum, a polynomial with integer coefficients, or of some other specific type.
GiNaC provides a couple of functions for this:

@example
bool is_a<T>(const ex & e);
bool is_exactly_a<T>(const ex & e);
bool ex::info(unsigned flag);
unsigned ex::return_type() const;
unsigned ex::return_type_tinfo() const;
@end example

When the test made by @code{is_a<T>()} returns true, it is safe to call
one of the functions @code{ex_to<T>()}, where @code{T} is one of the
class names (@xref{The Class Hierarchy}, for a list of all classes). For
example, assuming @code{e} is an @code{ex}:

@example
@{
    @dots{}
    if (is_a<numeric>(e))
        numeric n = ex_to<numeric>(e);
    @dots{}
@}
@end example

@code{is_a<T>(e)} allows you to check whether the top-level object of
an expression @samp{e} is an instance of the GiNaC class @samp{T}
(@xref{The Class Hierarchy}, for a list of all classes). This is most useful,
e.g., for checking whether an expression is a number, a sum, or a product:

@example
@{
    symbol x("x");
    ex e1 = 42;
    ex e2 = 4*x - 3;
    is_a<numeric>(e1);  // true
    is_a<numeric>(e2);  // false
    is_a<add>(e1);      // false
    is_a<add>(e2);      // true
    is_a<mul>(e1);      // false
    is_a<mul>(e2);      // false
@}
@end example

In contrast, @code{is_exactly_a<T>(e)} allows you to check whether the
top-level object of an expression @samp{e} is an instance of the GiNaC
class @samp{T}, not including parent classes.

The @code{info()} method is used for checking certain attributes of
expressions. The possible values for the @code{flag} argument are defined
in @file{ginac/flags.h}, the most important being explained in the following
table:

@cartouche
@multitable @columnfractions .30 .70
@item @strong{Flag} @tab @strong{Returns true if the object is@dots{}}
@item @code{numeric}
@tab @dots{}a number (same as @code{is_a<numeric>(...)})
@item @code{real}
@tab @dots{}a real integer, rational or float (i.e. is not complex)
@item @code{rational}
@tab @dots{}an exact rational number (integers are rational, too)
@item @code{integer}
@tab @dots{}a (non-complex) integer
@item @code{crational}
@tab @dots{}an exact (complex) rational number (such as @math{2/3+7/2*I})
@item @code{cinteger}
@tab @dots{}a (complex) integer (such as @math{2-3*I})
@item @code{positive}
@tab @dots{}not complex and greater than 0
@item @code{negative}
@tab @dots{}not complex and less than 0
@item @code{nonnegative}
@tab @dots{}not complex and greater than or equal to 0
@item @code{posint}
@tab @dots{}an integer greater than 0
@item @code{negint}
@tab @dots{}an integer less than 0
@item @code{nonnegint}
@tab @dots{}an integer greater than or equal to 0
@item @code{even}
@tab @dots{}an even integer
@item @code{odd}
@tab @dots{}an odd integer
@item @code{prime}
@tab @dots{}a prime integer (probabilistic primality test)
@item @code{relation}
@tab @dots{}a relation (same as @code{is_a<relational>(...)})
@item @code{relation_equal}
@tab @dots{}a @code{==} relation
@item @code{relation_not_equal}
@tab @dots{}a @code{!=} relation
@item @code{relation_less}
@tab @dots{}a @code{<} relation
@item @code{relation_less_or_equal}
@tab @dots{}a @code{<=} relation
@item @code{relation_greater}
@tab @dots{}a @code{>} relation
@item @code{relation_greater_or_equal}
@tab @dots{}a @code{>=} relation
@item @code{symbol}
@tab @dots{}a symbol (same as @code{is_a<symbol>(...)})
@item @code{list}
@tab @dots{}a list (same as @code{is_a<lst>(...)})
@item @code{polynomial}
@tab @dots{}a polynomial (i.e. only consists of sums and products of numbers and symbols with positive integer powers)
@item @code{integer_polynomial}
@tab @dots{}a polynomial with (non-complex) integer coefficients
@item @code{cinteger_polynomial}
@tab @dots{}a polynomial with (possibly complex) integer coefficients (such as @math{2-3*I})
@item @code{rational_polynomial}
@tab @dots{}a polynomial with (non-complex) rational coefficients
@item @code{crational_polynomial}
@tab @dots{}a polynomial with (possibly complex) rational coefficients (such as @math{2/3+7/2*I})
@item @code{rational_function}
@tab @dots{}a rational function (@math{x+y}, @math{z/(x+y)})
@item @code{algebraic}
@tab @dots{}an algebraic object (@math{sqrt(2)}, @math{sqrt(x)-1})
@end multitable
@end cartouche

To determine whether an expression is commutative or non-commutative and if
so, with which other expressions it would commutate, you use the methods
@code{return_type()} and @code{return_type_tinfo()}. @xref{Non-commutative objects},
for an explanation of these.


@subsection Accessing subexpressions
@cindex container

Many GiNaC classes, like @code{add}, @code{mul}, @code{lst}, and
@code{function}, act as containers for subexpressions. For example, the
subexpressions of a sum (an @code{add} object) are the individual terms,
and the subexpressions of a @code{function} are the function's arguments.

@cindex @code{nops()}
@cindex @code{op()}
GiNaC provides several ways of accessing subexpressions. The first way is to
use the two methods

@example
size_t ex::nops();
ex ex::op(size_t i);
@end example

@code{nops()} determines the number of subexpressions (operands) contained
in the expression, while @code{op(i)} returns the @code{i}-th
(0..@code{nops()-1}) subexpression. In the case of a @code{power} object,
@code{op(0)} will return the basis and @code{op(1)} the exponent. For
@code{indexed} objects, @code{op(0)} is the base expression and @code{op(i)},
@math{i>0} are the indices.

@cindex iterators
@cindex @code{const_iterator}
The second way to access subexpressions is via the STL-style random-access
iterator class @code{const_iterator} and the methods

@example
const_iterator ex::begin();
const_iterator ex::end();
@end example

@code{begin()} returns an iterator referring to the first subexpression;
@code{end()} returns an iterator which is one-past the last subexpression.
If the expression has no subexpressions, then @code{begin() == end()}. These
iterators can also be used in conjunction with non-modifying STL algorithms.

Here is an example that (non-recursively) prints the subexpressions of a
given expression in three different ways:

@example
@{
    ex e = ...

    // with nops()/op()
    for (size_t i = 0; i != e.nops(); ++i)
        cout << e.op(i) << endl;

    // with iterators
    for (const_iterator i = e.begin(); i != e.end(); ++i)
        cout << *i << endl;

    // with iterators and STL copy()
    std::copy(e.begin(), e.end(), std::ostream_iterator<ex>(cout, "\n"));
@}
@end example

@cindex @code{const_preorder_iterator}
@cindex @code{const_postorder_iterator}
@code{op()}/@code{nops()} and @code{const_iterator} only access an
expression's immediate children. GiNaC provides two additional iterator
classes, @code{const_preorder_iterator} and @code{const_postorder_iterator},
that iterate over all objects in an expression tree, in preorder or postorder,
respectively. They are STL-style forward iterators, and are created with the
methods

@example
const_preorder_iterator ex::preorder_begin();
const_preorder_iterator ex::preorder_end();
const_postorder_iterator ex::postorder_begin();
const_postorder_iterator ex::postorder_end();
@end example

The following example illustrates the differences between
@code{const_iterator}, @code{const_preorder_iterator}, and
@code{const_postorder_iterator}:

@example
@{
    symbol A("A"), B("B"), C("C");
    ex e = lst(lst(A, B), C);

    std::copy(e.begin(), e.end(),
              std::ostream_iterator<ex>(cout, "\n"));
    // @{A,B@}
    // C

    std::copy(e.preorder_begin(), e.preorder_end(),
              std::ostream_iterator<ex>(cout, "\n"));
    // @{@{A,B@},C@}
    // @{A,B@}
    // A
    // B
    // C

    std::copy(e.postorder_begin(), e.postorder_end(),
              std::ostream_iterator<ex>(cout, "\n"));
    // A
    // B
    // @{A,B@}
    // C
    // @{@{A,B@},C@}
@}
@end example

@cindex @code{relational} (class)
Finally, the left-hand side and right-hand side expressions of objects of
class @code{relational} (and only of these) can also be accessed with the
methods

@example
ex ex::lhs();
ex ex::rhs();
@end example


@subsection Comparing expressions
@cindex @code{is_equal()}
@cindex @code{is_zero()}

Expressions can be compared with the usual C++ relational operators like
@code{==}, @code{>}, and @code{<} but if the expressions contain symbols,
the result is usually not determinable and the result will be @code{false},
except in the case of the @code{!=} operator. You should also be aware that
GiNaC will only do the most trivial test for equality (subtracting both
expressions), so something like @code{(pow(x,2)+x)/x==x+1} will return
@code{false}.

Actually, if you construct an expression like @code{a == b}, this will be
represented by an object of the @code{relational} class (@pxref{Relations})
which is not evaluated until (explicitly or implicitly) cast to a @code{bool}.

There are also two methods

@example
bool ex::is_equal(const ex & other);
bool ex::is_zero();
@end example

for checking whether one expression is equal to another, or equal to zero,
respectively.


@subsection Ordering expressions
@cindex @code{ex_is_less} (class)
@cindex @code{ex_is_equal} (class)
@cindex @code{compare()}

Sometimes it is necessary to establish a mathematically well-defined ordering
on a set of arbitrary expressions, for example to use expressions as keys
in a @code{std::map<>} container, or to bring a vector of expressions into
a canonical order (which is done internally by GiNaC for sums and products).

The operators @code{<}, @code{>} etc. described in the last section cannot
be used for this, as they don't implement an ordering relation in the
mathematical sense. In particular, they are not guaranteed to be
antisymmetric: if @samp{a} and @samp{b} are different expressions, and
@code{a < b} yields @code{false}, then @code{b < a} doesn't necessarily
yield @code{true}.

By default, STL classes and algorithms use the @code{<} and @code{==}
operators to compare objects, which are unsuitable for expressions, but GiNaC
provides two functors that can be supplied as proper binary comparison
predicates to the STL:

@example
class ex_is_less : public std::binary_function<ex, ex, bool> @{
public:
    bool operator()(const ex &lh, const ex &rh) const;
@};

class ex_is_equal : public std::binary_function<ex, ex, bool> @{
public:
    bool operator()(const ex &lh, const ex &rh) const;
@};
@end example

For example, to define a @code{map} that maps expressions to strings you
have to use

@example
std::map<ex, std::string, ex_is_less> myMap;
@end example

Omitting the @code{ex_is_less} template parameter will introduce spurious
bugs because the map operates improperly.

Other examples for the use of the functors:

@example
std::vector<ex> v;
// fill vector
...

// sort vector
std::sort(v.begin(), v.end(), ex_is_less());

// count the number of expressions equal to '1'
unsigned num_ones = std::count_if(v.begin(), v.end(),
                                  std::bind2nd(ex_is_equal(), 1));
@end example

The implementation of @code{ex_is_less} uses the member function

@example
int ex::compare(const ex & other) const;
@end example

which returns @math{0} if @code{*this} and @code{other} are equal, @math{-1}
if @code{*this} sorts before @code{other}, and @math{1} if @code{*this} sorts
after @code{other}.


@node Numerical Evaluation, Substituting Expressions, Information About Expressions, Methods and Functions
@c    node-name, next, previous, up
@section Numerical Evaluation
@cindex @code{evalf()}

GiNaC keeps algebraic expressions, numbers and constants in their exact form.
To evaluate them using floating-point arithmetic you need to call

@example
ex ex::evalf(int level = 0) const;
@end example

@cindex @code{Digits}
The accuracy of the evaluation is controlled by the global object @code{Digits}
which can be assigned an integer value. The default value of @code{Digits}
is 17. @xref{Numbers}, for more information and examples.

To evaluate an expression to a @code{double} floating-point number you can
call @code{evalf()} followed by @code{numeric::to_double()}, like this:

@example
@{
    // Approximate sin(x/Pi)
    symbol x("x");
    ex e = series(sin(x/Pi), x == 0, 6);

    // Evaluate numerically at x=0.1
    ex f = evalf(e.subs(x == 0.1));

    // ex_to<numeric> is an unsafe cast, so check the type first
    if (is_a<numeric>(f)) @{
        double d = ex_to<numeric>(f).to_double();
        cout << d << endl;
         // -> 0.0318256
    @} else
        // error
@}
@end example


@node Substituting Expressions, Pattern Matching and Advanced Substitutions, Numerical Evaluation, Methods and Functions
@c    node-name, next, previous, up
@section Substituting expressions
@cindex @code{subs()}

Algebraic objects inside expressions can be replaced with arbitrary
expressions via the @code{.subs()} method:

@example
ex ex::subs(const ex & e, unsigned options = 0);
ex ex::subs(const exmap & m, unsigned options = 0);
ex ex::subs(const lst & syms, const lst & repls, unsigned options = 0);
@end example

In the first form, @code{subs()} accepts a relational of the form
@samp{object == expression} or a @code{lst} of such relationals:

@example
@{
    symbol x("x"), y("y");

    ex e1 = 2*x^2-4*x+3;
    cout << "e1(7) = " << e1.subs(x == 7) << endl;
     // -> 73

    ex e2 = x*y + x;
    cout << "e2(-2, 4) = " << e2.subs(lst(x == -2, y == 4)) << endl;
     // -> -10
@}
@end example

If you specify multiple substitutions, they are performed in parallel, so e.g.
@code{subs(lst(x == y, y == x))} exchanges @samp{x} and @samp{y}.

The second form of @code{subs()} takes an @code{exmap} object which is a
pair associative container that maps expressions to expressions (currently
implemented as a @code{std::map}). This is the most efficient one of the
three @code{subs()} forms and should be used when the number of objects to
be substituted is large or unknown.

Using this form, the second example from above would look like this:

@example
@{
    symbol x("x"), y("y");
    ex e2 = x*y + x;

    exmap m;
    m[x] = -2;
    m[y] = 4;
    cout << "e2(-2, 4) = " << e2.subs(m) << endl;
@}
@end example

The third form of @code{subs()} takes two lists, one for the objects to be
replaced and one for the expressions to be substituted (both lists must
contain the same number of elements). Using this form, you would write

@example
@{
    symbol x("x"), y("y");
    ex e2 = x*y + x;

    cout << "e2(-2, 4) = " << e2.subs(lst(x, y), lst(-2, 4)) << endl;
@}
@end example

The optional last argument to @code{subs()} is a combination of
@code{subs_options} flags. There are two options available:
@code{subs_options::no_pattern} disables pattern matching, which makes
large @code{subs()} operations significantly faster if you are not using
patterns. The second option, @code{subs_options::algebraic} enables
algebraic substitutions in products and powers.
@ref{Pattern Matching and Advanced Substitutions}, for more information
about patterns and algebraic substitutions.

@code{subs()} performs syntactic substitution of any complete algebraic
object; it does not try to match sub-expressions as is demonstrated by the
following example:

@example
@{
    symbol x("x"), y("y"), z("z");

    ex e1 = pow(x+y, 2);
    cout << e1.subs(x+y == 4) << endl;
     // -> 16

    ex e2 = sin(x)*sin(y)*cos(x);
    cout << e2.subs(sin(x) == cos(x)) << endl;
     // -> cos(x)^2*sin(y)

    ex e3 = x+y+z;
    cout << e3.subs(x+y == 4) << endl;
     // -> x+y+z
     // (and not 4+z as one might expect)
@}
@end example

A more powerful form of substitution using wildcards is described in the
next section.


@node Pattern Matching and Advanced Substitutions, Applying a Function on Subexpressions, Substituting Expressions, Methods and Functions
@c    node-name, next, previous, up
@section Pattern matching and advanced substitutions
@cindex @code{wildcard} (class)
@cindex Pattern matching

GiNaC allows the use of patterns for checking whether an expression is of a
certain form or contains subexpressions of a certain form, and for
substituting expressions in a more general way.

A @dfn{pattern} is an algebraic expression that optionally contains wildcards.
A @dfn{wildcard} is a special kind of object (of class @code{wildcard}) that
represents an arbitrary expression. Every wildcard has a @dfn{label} which is
an unsigned integer number to allow having multiple different wildcards in a
pattern. Wildcards are printed as @samp{$label} (this is also the way they
are specified in @command{ginsh}). In C++ code, wildcard objects are created
with the call

@example
ex wild(unsigned label = 0);
@end example

which is simply a wrapper for the @code{wildcard()} constructor with a shorter
name.

Some examples for patterns:

@multitable @columnfractions .5 .5
@item @strong{Constructed as} @tab @strong{Output as}
@item @code{wild()} @tab @samp{$0}
@item @code{pow(x,wild())} @tab @samp{x^$0}
@item @code{atan2(wild(1),wild(2))} @tab @samp{atan2($1,$2)}
@item @code{indexed(A,idx(wild(),3))} @tab @samp{A.$0}
@end multitable

Notes:

@itemize
@item Wildcards behave like symbols and are subject to the same algebraic
  rules. E.g., @samp{$0+2*$0} is automatically transformed to @samp{3*$0}.
@item As shown in the last example, to use wildcards for indices you have to
  use them as the value of an @code{idx} object. This is because indices must
  always be of class @code{idx} (or a subclass).
@item Wildcards only represent expressions or subexpressions. It is not
  possible to use them as placeholders for other properties like index
  dimension or variance, representation labels, symmetry of indexed objects
  etc.
@item Because wildcards are commutative, it is not possible to use wildcards
  as part of noncommutative products.
@item A pattern does not have to contain wildcards. @samp{x} and @samp{x+y}
  are also valid patterns.
@end itemize

@subsection Matching expressions
@cindex @code{match()}
The most basic application of patterns is to check whether an expression
matches a given pattern. This is done by the function

@example
bool ex::match(const ex & pattern);
bool ex::match(const ex & pattern, lst & repls);
@end example

This function returns @code{true} when the expression matches the pattern
and @code{false} if it doesn't. If used in the second form, the actual
subexpressions matched by the wildcards get returned in the @code{repls}
object as a list of relations of the form @samp{wildcard == expression}.
If @code{match()} returns false, the state of @code{repls} is undefined.
For reproducible results, the list should be empty when passed to
@code{match()}, but it is also possible to find similarities in multiple
expressions by passing in the result of a previous match.

The matching algorithm works as follows:

@itemize
@item A single wildcard matches any expression. If one wildcard appears
  multiple times in a pattern, it must match the same expression in all
  places (e.g. @samp{$0} matches anything, and @samp{$0*($0+1)} matches
  @samp{x*(x+1)} but not @samp{x*(y+1)}).
@item If the expression is not of the same class as the pattern, the match
  fails (i.e. a sum only matches a sum, a function only matches a function,
  etc.).
@item If the pattern is a function, it only matches the same function
  (i.e. @samp{sin($0)} matches @samp{sin(x)} but doesn't match @samp{exp(x)}).
@item Except for sums and products, the match fails if the number of
  subexpressions (@code{nops()}) is not equal to the number of subexpressions
  of the pattern.
@item If there are no subexpressions, the expressions and the pattern must
  be equal (in the sense of @code{is_equal()}).
@item Except for sums and products, each subexpression (@code{op()}) must
  match the corresponding subexpression of the pattern.
@end itemize

Sums (@code{add}) and products (@code{mul}) are treated in a special way to
account for their commutativity and associativity:

@itemize
@item If the pattern contains a term or factor that is a single wildcard,
  this one is used as the @dfn{global wildcard}. If there is more than one
  such wildcard, one of them is chosen as the global wildcard in a random
  way.
@item Every term/factor of the pattern, except the global wildcard, is
  matched against every term of the expression in sequence. If no match is
  found, the whole match fails. Terms that did match are not considered in
  further matches.
@item If there are no unmatched terms left, the match succeeds. Otherwise
  the match fails unless there is a global wildcard in the pattern, in
  which case this wildcard matches the remaining terms.
@end itemize

In general, having more than one single wildcard as a term of a sum or a
factor of a product (such as @samp{a+$0+$1}) will lead to unpredictable or
ambiguous results.

Here are some examples in @command{ginsh} to demonstrate how it works (the
@code{match()} function in @command{ginsh} returns @samp{FAIL} if the
match fails, and the list of wildcard replacements otherwise):

@example
> match((x+y)^a,(x+y)^a);
@{@}
> match((x+y)^a,(x+y)^b);
FAIL
> match((x+y)^a,$1^$2);
@{$1==x+y,$2==a@}
> match((x+y)^a,$1^$1);
FAIL
> match((x+y)^(x+y),$1^$1);
@{$1==x+y@}
> match((x+y)^(x+y),$1^$2);
@{$1==x+y,$2==x+y@}
> match((a+b)*(a+c),($1+b)*($1+c));
@{$1==a@}
> match((a+b)*(a+c),(a+$1)*(a+$2));
@{$1==c,$2==b@}
  (Unpredictable. The result might also be [$1==c,$2==b].)
> match((a+b)*(a+c),($1+$2)*($1+$3));
  (The result is undefined. Due to the sequential nature of the algorithm
   and the re-ordering of terms in GiNaC, the match for the first factor
   may be @{$1==a,$2==b@} in which case the match for the second factor
   succeeds, or it may be @{$1==b,$2==a@} which causes the second match to
   fail.)
> match(a*(x+y)+a*z+b,a*$1+$2);
  (This is also ambiguous and may return either @{$1==z,$2==a*(x+y)+b@} or
   @{$1=x+y,$2=a*z+b@}.)
> match(a+b+c+d+e+f,c);
FAIL
> match(a+b+c+d+e+f,c+$0);
@{$0==a+e+b+f+d@}
> match(a+b+c+d+e+f,c+e+$0);
@{$0==a+b+f+d@}
> match(a+b,a+b+$0);
@{$0==0@}
> match(a*b^2,a^$1*b^$2);
FAIL
  (The matching is syntactic, not algebraic, and "a" doesn't match "a^$1"
   even though a==a^1.)
> match(x*atan2(x,x^2),$0*atan2($0,$0^2));
@{$0==x@}
> match(atan2(y,x^2),atan2(y,$0));
@{$0==x^2@}
@end example

@subsection Matching parts of expressions
@cindex @code{has()}
A more general way to look for patterns in expressions is provided by the
member function

@example
bool ex::has(const ex & pattern);
@end example

This function checks whether a pattern is matched by an expression itself or
by any of its subexpressions.

Again some examples in @command{ginsh} for illustration (in @command{ginsh},
@code{has()} returns @samp{1} for @code{true} and @samp{0} for @code{false}):

@example
> has(x*sin(x+y+2*a),y);
1
> has(x*sin(x+y+2*a),x+y);
0
  (This is because in GiNaC, "x+y" is not a subexpression of "x+y+2*a" (which
   has the subexpressions "x", "y" and "2*a".)
> has(x*sin(x+y+2*a),x+y+$1);
1
  (But this is possible.)
> has(x*sin(2*(x+y)+2*a),x+y);
0
  (This fails because "2*(x+y)" automatically gets converted to "2*x+2*y" of
   which "x+y" is not a subexpression.)
> has(x+1,x^$1);
0
  (Although x^1==x and x^0==1, neither "x" nor "1" are actually of the form
   "x^something".)
> has(4*x^2-x+3,$1*x);
1
> has(4*x^2+x+3,$1*x);
0
  (Another possible pitfall. The first expression matches because the term
   "-x" has the form "(-1)*x" in GiNaC. To check whether a polynomial
   contains a linear term you should use the coeff() function instead.)
@end example

@cindex @code{find()}
The method

@example
bool ex::find(const ex & pattern, lst & found);
@end example

works a bit like @code{has()} but it doesn't stop upon finding the first
match. Instead, it appends all found matches to the specified list. If there
are multiple occurrences of the same expression, it is entered only once to
the list. @code{find()} returns false if no matches were found (in
@command{ginsh}, it returns an empty list):

@example
> find(1+x+x^2+x^3,x);
@{x@}
> find(1+x+x^2+x^3,y);
@{@}
> find(1+x+x^2+x^3,x^$1);
@{x^3,x^2@}
  (Note the absence of "x".)
> expand((sin(x)+sin(y))*(a+b));
sin(y)*a+sin(x)*b+sin(x)*a+sin(y)*b
> find(%,sin($1));
@{sin(y),sin(x)@}
@end example

@subsection Substituting expressions
@cindex @code{subs()}
Probably the most useful application of patterns is to use them for
substituting expressions with the @code{subs()} method. Wildcards can be
used in the search patterns as well as in the replacement expressions, where
they get replaced by the expressions matched by them. @code{subs()} doesn't
know anything about algebra; it performs purely syntactic substitutions.

Some examples:

@example
> subs(a^2+b^2+(x+y)^2,$1^2==$1^3);
b^3+a^3+(x+y)^3
> subs(a^4+b^4+(x+y)^4,$1^2==$1^3);
b^4+a^4+(x+y)^4
> subs((a+b+c)^2,a+b==x);
(a+b+c)^2
> subs((a+b+c)^2,a+b+$1==x+$1);
(x+c)^2
> subs(a+2*b,a+b==x);
a+2*b
> subs(4*x^3-2*x^2+5*x-1,x==a);
-1+5*a-2*a^2+4*a^3
> subs(4*x^3-2*x^2+5*x-1,x^$0==a^$0);
-1+5*x-2*a^2+4*a^3
> subs(sin(1+sin(x)),sin($1)==cos($1));
cos(1+cos(x))
> expand(subs(a*sin(x+y)^2+a*cos(x+y)^2+b,cos($1)^2==1-sin($1)^2));
a+b
@end example

The last example would be written in C++ in this way:

@example
@{
    symbol a("a"), b("b"), x("x"), y("y");
    e = a*pow(sin(x+y), 2) + a*pow(cos(x+y), 2) + b;
    e = e.subs(pow(cos(wild()), 2) == 1-pow(sin(wild()), 2));
    cout << e.expand() << endl;
     // -> a+b
@}
@end example

@subsection Algebraic substitutions
Supplying the @code{subs_options::algebraic} option to @code{subs()}
enables smarter, algebraic substitutions in products and powers. If you want
to substitute some factors of a product, you only need to list these factors
in your pattern. Furthermore, if an (integer) power of some expression occurs
in your pattern and in the expression that you want the substitution to occur
in, it can be substituted as many times as possible, without getting negative
powers.

An example clarifies it all (hopefully):

@example
cout << (a*a*a*a+b*b*b*b+pow(x+y,4)).subs(wild()*wild()==pow(wild(),3),
                                        subs_options::algebraic) << endl;
// --> (y+x)^6+b^6+a^6

cout << ((a+b+c)*(a+b+c)).subs(a+b==x,subs_options::algebraic) << endl;
// --> (c+b+a)^2
// Powers and products are smart, but addition is just the same.

cout << ((a+b+c)*(a+b+c)).subs(a+b+wild()==x+wild(), subs_options::algebraic)
                                                                      << endl;
// --> (x+c)^2
// As I said: addition is just the same.

cout << (pow(a,5)*pow(b,7)+2*b).subs(b*b*a==x,subs_options::algebraic) << endl;
// --> x^3*b*a^2+2*b

cout << (pow(a,-5)*pow(b,-7)+2*b).subs(1/(b*b*a)==x,subs_options::algebraic)
                                                                       << endl;
// --> 2*b+x^3*b^(-1)*a^(-2)

cout << (4*x*x*x-2*x*x+5*x-1).subs(x==a,subs_options::algebraic) << endl;
// --> -1-2*a^2+4*a^3+5*a

cout << (4*x*x*x-2*x*x+5*x-1).subs(pow(x,wild())==pow(a,wild()),
                                subs_options::algebraic) << endl;
// --> -1+5*x+4*x^3-2*x^2
// You should not really need this kind of patterns very often now.
// But perhaps this it's-not-a-bug-it's-a-feature (c/sh)ould still change.

cout << ex(sin(1+sin(x))).subs(sin(wild())==cos(wild()),
                                subs_options::algebraic) << endl;
// --> cos(1+cos(x))

cout << expand((a*sin(x+y)*sin(x+y)+a*cos(x+y)*cos(x+y)+b)
        .subs((pow(cos(wild()),2)==1-pow(sin(wild()),2)),
                                subs_options::algebraic)) << endl;
// --> b+a
@end example


@node Applying a Function on Subexpressions, Visitors and Tree Traversal, Pattern Matching and Advanced Substitutions, Methods and Functions
@c    node-name, next, previous, up
@section Applying a Function on Subexpressions
@cindex tree traversal
@cindex @code{map()}

Sometimes you may want to perform an operation on specific parts of an
expression while leaving the general structure of it intact. An example
of this would be a matrix trace operation: the trace of a sum is the sum
of the traces of the individual terms. That is, the trace should @dfn{map}
on the sum, by applying itself to each of the sum's operands. It is possible
to do this manually which usually results in code like this:

@example
ex calc_trace(ex e)
@{
    if (is_a<matrix>(e))
        return ex_to<matrix>(e).trace();
    else if (is_a<add>(e)) @{
        ex sum = 0;
        for (size_t i=0; i<e.nops(); i++)
            sum += calc_trace(e.op(i));
        return sum;
    @} else if (is_a<mul>)(e)) @{
        ...
    @} else @{
        ...
    @}
@}
@end example

This is, however, slightly inefficient (if the sum is very large it can take
a long time to add the terms one-by-one), and its applicability is limited to
a rather small class of expressions. If @code{calc_trace()} is called with
a relation or a list as its argument, you will probably want the trace to
be taken on both sides of the relation or of all elements of the list.

GiNaC offers the @code{map()} method to aid in the implementation of such
operations:

@example
ex ex::map(map_function & f) const;
ex ex::map(ex (*f)(const ex & e)) const;
@end example

In the first (preferred) form, @code{map()} takes a function object that
is subclassed from the @code{map_function} class. In the second form, it
takes a pointer to a function that accepts and returns an expression.
@code{map()} constructs a new expression of the same type, applying the
specified function on all subexpressions (in the sense of @code{op()}),
non-recursively.

The use of a function object makes it possible to supply more arguments to
the function that is being mapped, or to keep local state information.
The @code{map_function} class declares a virtual function call operator
that you can overload. Here is a sample implementation of @code{calc_trace()}
that uses @code{map()} in a recursive fashion:

@example
struct calc_trace : public map_function @{
    ex operator()(const ex &e)
    @{
        if (is_a<matrix>(e))
            return ex_to<matrix>(e).trace();
        else if (is_a<mul>(e)) @{
            ...
        @} else
            return e.map(*this);
    @}
@};
@end example

This function object could then be used like this:

@example
@{
    ex M = ... // expression with matrices
    calc_trace do_trace;
    ex tr = do_trace(M);
@}
@end example

Here is another example for you to meditate over.  It removes quadratic
terms in a variable from an expanded polynomial:

@example
struct map_rem_quad : public map_function @{
    ex var;
    map_rem_quad(const ex & var_) : var(var_) @{@}

    ex operator()(const ex & e)
    @{
        if (is_a<add>(e) || is_a<mul>(e))
     	    return e.map(*this);
        else if (is_a<power>(e) && 
                 e.op(0).is_equal(var) && e.op(1).info(info_flags::even))
            return 0;
        else
            return e;
    @}
@};

...

@{
    symbol x("x"), y("y");

    ex e;
    for (int i=0; i<8; i++)
        e += pow(x, i) * pow(y, 8-i) * (i+1);
    cout << e << endl;
     // -> 4*y^5*x^3+5*y^4*x^4+8*y*x^7+7*y^2*x^6+2*y^7*x+6*y^3*x^5+3*y^6*x^2+y^8

    map_rem_quad rem_quad(x);
    cout << rem_quad(e) << endl;
     // -> 4*y^5*x^3+8*y*x^7+2*y^7*x+6*y^3*x^5+y^8
@}
@end example

@command{ginsh} offers a slightly different implementation of @code{map()}
that allows applying algebraic functions to operands. The second argument
to @code{map()} is an expression containing the wildcard @samp{$0} which
acts as the placeholder for the operands:

@example
> map(a*b,sin($0));
sin(a)*sin(b)
> map(a+2*b,sin($0));
sin(a)+sin(2*b)
> map(@{a,b,c@},$0^2+$0);
@{a^2+a,b^2+b,c^2+c@}
@end example

Note that it is only possible to use algebraic functions in the second
argument. You can not use functions like @samp{diff()}, @samp{op()},
@samp{subs()} etc. because these are evaluated immediately:

@example
> map(@{a,b,c@},diff($0,a));
@{0,0,0@}
  This is because "diff($0,a)" evaluates to "0", so the command is equivalent
  to "map(@{a,b,c@},0)".
@end example


@node Visitors and Tree Traversal, Polynomial Arithmetic, Applying a Function on Subexpressions, Methods and Functions
@c    node-name, next, previous, up
@section Visitors and Tree Traversal
@cindex tree traversal
@cindex @code{visitor} (class)
@cindex @code{accept()}
@cindex @code{visit()}
@cindex @code{traverse()}
@cindex @code{traverse_preorder()}
@cindex @code{traverse_postorder()}

Suppose that you need a function that returns a list of all indices appearing
in an arbitrary expression. The indices can have any dimension, and for
indices with variance you always want the covariant version returned.

You can't use @code{get_free_indices()} because you also want to include
dummy indices in the list, and you can't use @code{find()} as it needs
specific index dimensions (and it would require two passes: one for indices
with variance, one for plain ones).

The obvious solution to this problem is a tree traversal with a type switch,
such as the following:

@example
void gather_indices_helper(const ex & e, lst & l)
@{
    if (is_a<varidx>(e)) @{
        const varidx & vi = ex_to<varidx>(e);
        l.append(vi.is_covariant() ? vi : vi.toggle_variance());
    @} else if (is_a<idx>(e)) @{
        l.append(e);
    @} else @{
        size_t n = e.nops();
        for (size_t i = 0; i < n; ++i)
            gather_indices_helper(e.op(i), l);
    @}
@}

lst gather_indices(const ex & e)
@{
    lst l;
    gather_indices_helper(e, l);
    l.sort();
    l.unique();
    return l;
@}
@end example

This works fine but fans of object-oriented programming will feel
uncomfortable with the type switch. One reason is that there is a possibility
for subtle bugs regarding derived classes. If we had, for example, written

@example
    if (is_a<idx>(e)) @{
      ...
    @} else if (is_a<varidx>(e)) @{
      ...
@end example

in @code{gather_indices_helper}, the code wouldn't have worked because the
first line "absorbs" all classes derived from @code{idx}, including
@code{varidx}, so the special case for @code{varidx} would never have been
executed.

Also, for a large number of classes, a type switch like the above can get
unwieldy and inefficient (it's a linear search, after all).
@code{gather_indices_helper} only checks for two classes, but if you had to
write a function that required a different implementation for nearly
every GiNaC class, the result would be very hard to maintain and extend.

The cleanest approach to the problem would be to add a new virtual function
to GiNaC's class hierarchy. In our example, there would be specializations
for @code{idx} and @code{varidx} while the default implementation in
@code{basic} performed the tree traversal. Unfortunately, in C++ it's
impossible to add virtual member functions to existing classes without
changing their source and recompiling everything. GiNaC comes with source,
so you could actually do this, but for a small algorithm like the one
presented this would be impractical.

One solution to this dilemma is the @dfn{Visitor} design pattern,
which is implemented in GiNaC (actually, Robert Martin's Acyclic Visitor
variation, described in detail in
@uref{http://objectmentor.com/publications/acv.pdf}). Instead of adding
virtual functions to the class hierarchy to implement operations, GiNaC
provides a single "bouncing" method @code{accept()} that takes an instance
of a special @code{visitor} class and redirects execution to the one
@code{visit()} virtual function of the visitor that matches the type of
object that @code{accept()} was being invoked on.

Visitors in GiNaC must derive from the global @code{visitor} class as well
as from the class @code{T::visitor} of each class @code{T} they want to
visit, and implement the member functions @code{void visit(const T &)} for
each class.

A call of

@example
void ex::accept(visitor & v) const;
@end example

will then dispatch to the correct @code{visit()} member function of the
specified visitor @code{v} for the type of GiNaC object at the root of the
expression tree (e.g. a @code{symbol}, an @code{idx} or a @code{mul}).

Here is an example of a visitor:

@example
class my_visitor
 : public visitor,          // this is required
   public add::visitor,     // visit add objects
   public numeric::visitor, // visit numeric objects
   public basic::visitor    // visit basic objects
@{
    void visit(const add & x)
    @{ cout << "called with an add object" << endl; @}

    void visit(const numeric & x)
    @{ cout << "called with a numeric object" << endl; @}

    void visit(const basic & x)
    @{ cout << "called with a basic object" << endl; @}
@};
@end example

which can be used as follows:

@example
...
    symbol x("x");
    ex e1 = 42;
    ex e2 = 4*x-3;
    ex e3 = 8*x;

    my_visitor v;
    e1.accept(v);
     // prints "called with a numeric object"
    e2.accept(v);
     // prints "called with an add object"
    e3.accept(v);
     // prints "called with a basic object"
...
@end example

The @code{visit(const basic &)} method gets called for all objects that are
not @code{numeric} or @code{add} and acts as an (optional) default.

From a conceptual point of view, the @code{visit()} methods of the visitor
behave like a newly added virtual function of the visited hierarchy.
In addition, visitors can store state in member variables, and they can
be extended by deriving a new visitor from an existing one, thus building
hierarchies of visitors.

We can now rewrite our index example from above with a visitor:

@example
class gather_indices_visitor
 : public visitor, public idx::visitor, public varidx::visitor
@{
    lst l;

    void visit(const idx & i)
    @{
        l.append(i);
    @}

    void visit(const varidx & vi)
    @{
        l.append(vi.is_covariant() ? vi : vi.toggle_variance());
    @}

public:
    const lst & get_result() // utility function
    @{
        l.sort();
        l.unique();
        return l;
    @}
@};
@end example

What's missing is the tree traversal. We could implement it in
@code{visit(const basic &)}, but GiNaC has predefined methods for this:

@example
void ex::traverse_preorder(visitor & v) const;
void ex::traverse_postorder(visitor & v) const;
void ex::traverse(visitor & v) const;
@end example

@code{traverse_preorder()} visits a node @emph{before} visiting its
subexpressions, while @code{traverse_postorder()} visits a node @emph{after}
visiting its subexpressions. @code{traverse()} is a synonym for
@code{traverse_preorder()}.

Here is a new implementation of @code{gather_indices()} that uses the visitor
and @code{traverse()}:

@example
lst gather_indices(const ex & e)
@{
    gather_indices_visitor v;
    e.traverse(v);
    return v.get_result();
@}
@end example

Alternatively, you could use pre- or postorder iterators for the tree
traversal:

@example
lst gather_indices(const ex & e)
@{
    gather_indices_visitor v;
    for (const_preorder_iterator i = e.preorder_begin();
         i != e.preorder_end(); ++i) @{
        i->accept(v);
    @}
    return v.get_result();
@}
@end example


@node Polynomial Arithmetic, Rational Expressions, Visitors and Tree Traversal, Methods and Functions
@c    node-name, next, previous, up
@section Polynomial arithmetic

@subsection Expanding and collecting
@cindex @code{expand()}
@cindex @code{collect()}
@cindex @code{collect_common_factors()}

A polynomial in one or more variables has many equivalent
representations.  Some useful ones serve a specific purpose.  Consider
for example the trivariate polynomial @math{4*x*y + x*z + 20*y^2 +
21*y*z + 4*z^2} (written down here in output-style).  It is equivalent
to the factorized polynomial @math{(x + 5*y + 4*z)*(4*y + z)}.  Other
representations are the recursive ones where one collects for exponents
in one of the three variable.  Since the factors are themselves
polynomials in the remaining two variables the procedure can be
repeated.  In our example, two possibilities would be @math{(4*y + z)*x
+ 20*y^2 + 21*y*z + 4*z^2} and @math{20*y^2 + (21*z + 4*x)*y + 4*z^2 +
x*z}.

To bring an expression into expanded form, its method

@example
ex ex::expand(unsigned options = 0);
@end example

may be called.  In our example above, this corresponds to @math{4*x*y +
x*z + 20*y^2 + 21*y*z + 4*z^2}.  Again, since the canonical form in
GiNaC is not easy to guess you should be prepared to see different
orderings of terms in such sums!

Another useful representation of multivariate polynomials is as a
univariate polynomial in one of the variables with the coefficients
being polynomials in the remaining variables.  The method
@code{collect()} accomplishes this task:

@example
ex ex::collect(const ex & s, bool distributed = false);
@end example

The first argument to @code{collect()} can also be a list of objects in which
case the result is either a recursively collected polynomial, or a polynomial
in a distributed form with terms like @math{c*x1^e1*...*xn^en}, as specified
by the @code{distributed} flag.

Note that the original polynomial needs to be in expanded form (for the
variables concerned) in order for @code{collect()} to be able to find the
coefficients properly.

The following @command{ginsh} transcript shows an application of @code{collect()}
together with @code{find()}:

@example
> a=expand((sin(x)+sin(y))*(1+p+q)*(1+d));
d*p*sin(x)+p*sin(x)+q*d*sin(x)+q*sin(y)+d*sin(x)+q*d*sin(y)+sin(y)+d*sin(y)+q*sin(x)+d*sin(y)*p+sin(x)+sin(y)*p
> collect(a,@{p,q@});
d*sin(x)+(d*sin(x)+sin(y)+d*sin(y)+sin(x))*p+(d*sin(x)+sin(y)+d*sin(y)+sin(x))*q+sin(y)+d*sin(y)+sin(x)
> collect(a,find(a,sin($1)));
(1+q+d+q*d+d*p+p)*sin(y)+(1+q+d+q*d+d*p+p)*sin(x)
> collect(a,@{find(a,sin($1)),p,q@});
(1+(1+d)*p+d+q*(1+d))*sin(x)+(1+(1+d)*p+d+q*(1+d))*sin(y)
> collect(a,@{find(a,sin($1)),d@});
(1+q+d*(1+q+p)+p)*sin(y)+(1+q+d*(1+q+p)+p)*sin(x)
@end example

Polynomials can often be brought into a more compact form by collecting
common factors from the terms of sums. This is accomplished by the function

@example
ex collect_common_factors(const ex & e);
@end example

This function doesn't perform a full factorization but only looks for
factors which are already explicitly present:

@example
> collect_common_factors(a*x+a*y);
(x+y)*a
> collect_common_factors(a*x^2+2*a*x*y+a*y^2);
a*(2*x*y+y^2+x^2)
> collect_common_factors(a*(b*(a+c)*x+b*((a+c)*x+(a+c)*y)*y));
(c+a)*a*(x*y+y^2+x)*b
@end example

@subsection Degree and coefficients
@cindex @code{degree()}
@cindex @code{ldegree()}
@cindex @code{coeff()}

The degree and low degree of a polynomial can be obtained using the two
methods

@example
int ex::degree(const ex & s);
int ex::ldegree(const ex & s);
@end example

which also work reliably on non-expanded input polynomials (they even work
on rational functions, returning the asymptotic degree). By definition, the
degree of zero is zero. To extract a coefficient with a certain power from
an expanded polynomial you use

@example
ex ex::coeff(const ex & s, int n);
@end example

You can also obtain the leading and trailing coefficients with the methods

@example
ex ex::lcoeff(const ex & s);
ex ex::tcoeff(const ex & s);
@end example

which are equivalent to @code{coeff(s, degree(s))} and @code{coeff(s, ldegree(s))},
respectively.

An application is illustrated in the next example, where a multivariate
polynomial is analyzed:

@example
@{
    symbol x("x"), y("y");
    ex PolyInp = 4*pow(x,3)*y + 5*x*pow(y,2) + 3*y
                 - pow(x+y,2) + 2*pow(y+2,2) - 8;
    ex Poly = PolyInp.expand();
    
    for (int i=Poly.ldegree(x); i<=Poly.degree(x); ++i) @{
        cout << "The x^" << i << "-coefficient is "
             << Poly.coeff(x,i) << endl;
    @}
    cout << "As polynomial in y: " 
         << Poly.collect(y) << endl;
@}
@end example

When run, it returns an output in the following fashion:

@example
The x^0-coefficient is y^2+11*y
The x^1-coefficient is 5*y^2-2*y
The x^2-coefficient is -1
The x^3-coefficient is 4*y
As polynomial in y: -x^2+(5*x+1)*y^2+(-2*x+4*x^3+11)*y
@end example

As always, the exact output may vary between different versions of GiNaC
or even from run to run since the internal canonical ordering is not
within the user's sphere of influence.

@code{degree()}, @code{ldegree()}, @code{coeff()}, @code{lcoeff()},
@code{tcoeff()} and @code{collect()} can also be used to a certain degree
with non-polynomial expressions as they not only work with symbols but with
constants, functions and indexed objects as well:

@example
@{
    symbol a("a"), b("b"), c("c"), x("x");
    idx i(symbol("i"), 3);

    ex e = pow(sin(x) - cos(x), 4);
    cout << e.degree(cos(x)) << endl;
     // -> 4
    cout << e.expand().coeff(sin(x), 3) << endl;
     // -> -4*cos(x)

    e = indexed(a+b, i) * indexed(b+c, i); 
    e = e.expand(expand_options::expand_indexed);
    cout << e.collect(indexed(b, i)) << endl;
     // -> a.i*c.i+(a.i+c.i)*b.i+b.i^2
@}
@end example


@subsection Polynomial division
@cindex polynomial division
@cindex quotient
@cindex remainder
@cindex pseudo-remainder
@cindex @code{quo()}
@cindex @code{rem()}
@cindex @code{prem()}
@cindex @code{divide()}

The two functions

@example
ex quo(const ex & a, const ex & b, const ex & x);
ex rem(const ex & a, const ex & b, const ex & x);
@end example

compute the quotient and remainder of univariate polynomials in the variable
@samp{x}. The results satisfy @math{a = b*quo(a, b, x) + rem(a, b, x)}.

The additional function

@example
ex prem(const ex & a, const ex & b, const ex & x);
@end example

computes the pseudo-remainder of @samp{a} and @samp{b} which satisfies
@math{c*a = b*q + prem(a, b, x)}, where @math{c = b.lcoeff(x) ^ (a.degree(x) - b.degree(x) + 1)}.

Exact division of multivariate polynomials is performed by the function

@example
bool divide(const ex & a, const ex & b, ex & q);
@end example

If @samp{b} divides @samp{a} over the rationals, this function returns @code{true}
and returns the quotient in the variable @code{q}. Otherwise it returns @code{false}
in which case the value of @code{q} is undefined.


@subsection Unit, content and primitive part
@cindex @code{unit()}
@cindex @code{content()}
@cindex @code{primpart()}

The methods

@example
ex ex::unit(const ex & x);
ex ex::content(const ex & x);
ex ex::primpart(const ex & x);
@end example

return the unit part, content part, and primitive polynomial of a multivariate
polynomial with respect to the variable @samp{x} (the unit part being the sign
of the leading coefficient, the content part being the GCD of the coefficients,
and the primitive polynomial being the input polynomial divided by the unit and
content parts). The product of unit, content, and primitive part is the
original polynomial.


@subsection GCD, LCM and resultant
@cindex GCD
@cindex LCM
@cindex @code{gcd()}
@cindex @code{lcm()}

The functions for polynomial greatest common divisor and least common
multiple have the synopsis

@example
ex gcd(const ex & a, const ex & b);
ex lcm(const ex & a, const ex & b);
@end example

The functions @code{gcd()} and @code{lcm()} accept two expressions
@code{a} and @code{b} as arguments and return a new expression, their
greatest common divisor or least common multiple, respectively.  If the
polynomials @code{a} and @code{b} are coprime @code{gcd(a,b)} returns 1
and @code{lcm(a,b)} returns the product of @code{a} and @code{b}.

@example
#include <ginac/ginac.h>
using namespace GiNaC;

int main()
@{
    symbol x("x"), y("y"), z("z");
    ex P_a = 4*x*y + x*z + 20*pow(y, 2) + 21*y*z + 4*pow(z, 2);
    ex P_b = x*y + 3*x*z + 5*pow(y, 2) + 19*y*z + 12*pow(z, 2);

    ex P_gcd = gcd(P_a, P_b);
    // x + 5*y + 4*z
    ex P_lcm = lcm(P_a, P_b);
    // 4*x*y^2 + 13*y*x*z + 20*y^3 + 81*y^2*z + 67*y*z^2 + 3*x*z^2 + 12*z^3
@}
@end example

@cindex resultant
@cindex @code{resultant()}

The resultant of two expressions only makes sense with polynomials.
It is always computed with respect to a specific symbol within the
expressions. The function has the interface

@example
ex resultant(const ex & a, const ex & b, const ex & s);
@end example

Resultants are symmetric in @code{a} and @code{b}. The following example
computes the resultant of two expressions with respect to @code{x} and
@code{y}, respectively:

@example
#include <ginac/ginac.h>
using namespace GiNaC;

int main()
@{
    symbol x("x"), y("y");

    ex e1 = x+pow(y,2), e2 = 2*pow(x,3)-1; // x+y^2, 2*x^3-1
    ex r;
    
    r = resultant(e1, e2, x); 
    // -> 1+2*y^6
    r = resultant(e1, e2, y); 
    // -> 1-4*x^3+4*x^6
@}
@end example

@subsection Square-free decomposition
@cindex square-free decomposition
@cindex factorization
@cindex @code{sqrfree()}

GiNaC still lacks proper factorization support.  Some form of
factorization is, however, easily implemented by noting that factors
appearing in a polynomial with power two or more also appear in the
derivative and hence can easily be found by computing the GCD of the
original polynomial and its derivatives.  Any decent system has an
interface for this so called square-free factorization.  So we provide
one, too:
@example
ex sqrfree(const ex & a, const lst & l = lst());
@end example
Here is an example that by the way illustrates how the exact form of the
result may slightly depend on the order of differentiation, calling for
some care with subsequent processing of the result:
@example
    ...
    symbol x("x"), y("y");
    ex BiVarPol = expand(pow(2-2*y,3) * pow(1+x*y,2) * pow(x-2*y,2) * (x+y));

    cout << sqrfree(BiVarPol, lst(x,y)) << endl;
     // -> 8*(1-y)^3*(y*x^2-2*y+x*(1-2*y^2))^2*(y+x)

    cout << sqrfree(BiVarPol, lst(y,x)) << endl;
     // -> 8*(1-y)^3*(-y*x^2+2*y+x*(-1+2*y^2))^2*(y+x)

    cout << sqrfree(BiVarPol) << endl;
     // -> depending on luck, any of the above
    ...
@end example
Note also, how factors with the same exponents are not fully factorized
with this method.


@node Rational Expressions, Symbolic Differentiation, Polynomial Arithmetic, Methods and Functions
@c    node-name, next, previous, up
@section Rational expressions

@subsection The @code{normal} method
@cindex @code{normal()}
@cindex simplification
@cindex temporary replacement

Some basic form of simplification of expressions is called for frequently.
GiNaC provides the method @code{.normal()}, which converts a rational function
into an equivalent rational function of the form @samp{numerator/denominator}
where numerator and denominator are coprime.  If the input expression is already
a fraction, it just finds the GCD of numerator and denominator and cancels it,
otherwise it performs fraction addition and multiplication.

@code{.normal()} can also be used on expressions which are not rational functions
as it will replace all non-rational objects (like functions or non-integer
powers) by temporary symbols to bring the expression to the domain of rational
functions before performing the normalization, and re-substituting these
symbols afterwards. This algorithm is also available as a separate method
@code{.to_rational()}, described below.

This means that both expressions @code{t1} and @code{t2} are indeed
simplified in this little code snippet:

@example
@{
    symbol x("x");
    ex t1 = (pow(x,2) + 2*x + 1)/(x + 1);
    ex t2 = (pow(sin(x),2) + 2*sin(x) + 1)/(sin(x) + 1);
    std::cout << "t1 is " << t1.normal() << std::endl;
    std::cout << "t2 is " << t2.normal() << std::endl;
@}
@end example

Of course this works for multivariate polynomials too, so the ratio of
the sample-polynomials from the section about GCD and LCM above would be
normalized to @code{P_a/P_b} = @code{(4*y+z)/(y+3*z)}.


@subsection Numerator and denominator
@cindex numerator
@cindex denominator
@cindex @code{numer()}
@cindex @code{denom()}
@cindex @code{numer_denom()}

The numerator and denominator of an expression can be obtained with

@example
ex ex::numer();
ex ex::denom();
ex ex::numer_denom();
@end example

These functions will first normalize the expression as described above and
then return the numerator, denominator, or both as a list, respectively.
If you need both numerator and denominator, calling @code{numer_denom()} is
faster than using @code{numer()} and @code{denom()} separately.


@subsection Converting to a polynomial or rational expression
@cindex @code{to_polynomial()}
@cindex @code{to_rational()}

Some of the methods described so far only work on polynomials or rational
functions. GiNaC provides a way to extend the domain of these functions to
general expressions by using the temporary replacement algorithm described
above. You do this by calling

@example
ex ex::to_polynomial(exmap & m);
ex ex::to_polynomial(lst & l);
@end example
or
@example
ex ex::to_rational(exmap & m);
ex ex::to_rational(lst & l);
@end example

on the expression to be converted. The supplied @code{exmap} or @code{lst}
will be filled with the generated temporary symbols and their replacement
expressions in a format that can be used directly for the @code{subs()}
method. It can also already contain a list of replacements from an earlier
application of @code{.to_polynomial()} or @code{.to_rational()}, so it's
possible to use it on multiple expressions and get consistent results.

The difference between @code{.to_polynomial()} and @code{.to_rational()}
is probably best illustrated with an example:

@example
@{
    symbol x("x"), y("y");
    ex a = 2*x/sin(x) - y/(3*sin(x));
    cout << a << endl;

    lst lp;
    ex p = a.to_polynomial(lp);
    cout << " = " << p << "\n   with " << lp << endl;
     // = symbol3*symbol2*y+2*symbol2*x
     //   with @{symbol2==sin(x)^(-1),symbol3==-1/3@}

    lst lr;
    ex r = a.to_rational(lr);
    cout << " = " << r << "\n   with " << lr << endl;
     // = -1/3*symbol4^(-1)*y+2*symbol4^(-1)*x
     //   with @{symbol4==sin(x)@}
@}
@end example

The following more useful example will print @samp{sin(x)-cos(x)}:

@example
@{
    symbol x("x");
    ex a = pow(sin(x), 2) - pow(cos(x), 2);
    ex b = sin(x) + cos(x);
    ex q;
    exmap m;
    divide(a.to_polynomial(m), b.to_polynomial(m), q);
    cout << q.subs(m) << endl;
@}
@end example


@node Symbolic Differentiation, Series Expansion, Rational Expressions, Methods and Functions
@c    node-name, next, previous, up
@section Symbolic differentiation
@cindex differentiation
@cindex @code{diff()}
@cindex chain rule
@cindex product rule

GiNaC's objects know how to differentiate themselves.  Thus, a
polynomial (class @code{add}) knows that its derivative is the sum of
the derivatives of all the monomials:

@example
@{
    symbol x("x"), y("y"), z("z");
    ex P = pow(x, 5) + pow(x, 2) + y;

    cout << P.diff(x,2) << endl;
     // -> 20*x^3 + 2
    cout << P.diff(y) << endl;    // 1
     // -> 1
    cout << P.diff(z) << endl;    // 0
     // -> 0
@}
@end example

If a second integer parameter @var{n} is given, the @code{diff} method
returns the @var{n}th derivative.

If @emph{every} object and every function is told what its derivative
is, all derivatives of composed objects can be calculated using the
chain rule and the product rule.  Consider, for instance the expression
@code{1/cosh(x)}.  Since the derivative of @code{cosh(x)} is
@code{sinh(x)} and the derivative of @code{pow(x,-1)} is
@code{-pow(x,-2)}, GiNaC can readily compute the composition.  It turns
out that the composition is the generating function for Euler Numbers,
i.e. the so called @var{n}th Euler number is the coefficient of
@code{x^n/n!} in the expansion of @code{1/cosh(x)}.  We may use this
identity to code a function that generates Euler numbers in just three
lines:

@cindex Euler numbers
@example
#include <ginac/ginac.h>
using namespace GiNaC;

ex EulerNumber(unsigned n)
@{
    symbol x;
    const ex generator = pow(cosh(x),-1);
    return generator.diff(x,n).subs(x==0);
@}

int main()
@{
    for (unsigned i=0; i<11; i+=2)
        std::cout << EulerNumber(i) << std::endl;
    return 0;
@}
@end example

When you run it, it produces the sequence @code{1}, @code{-1}, @code{5},
@code{-61}, @code{1385}, @code{-50521}.  We increment the loop variable
@code{i} by two since all odd Euler numbers vanish anyways.


@node Series Expansion, Symmetrization, Symbolic Differentiation, Methods and Functions
@c    node-name, next, previous, up
@section Series expansion
@cindex @code{series()}
@cindex Taylor expansion
@cindex Laurent expansion
@cindex @code{pseries} (class)
@cindex @code{Order()}

Expressions know how to expand themselves as a Taylor series or (more
generally) a Laurent series.  As in most conventional Computer Algebra
Systems, no distinction is made between those two.  There is a class of
its own for storing such series (@code{class pseries}) and a built-in
function (called @code{Order}) for storing the order term of the series.
As a consequence, if you want to work with series, i.e. multiply two
series, you need to call the method @code{ex::series} again to convert
it to a series object with the usual structure (expansion plus order
term).  A sample application from special relativity could read:

@example
#include <ginac/ginac.h>
using namespace std;
using namespace GiNaC;

int main()
@{
    symbol v("v"), c("c");
    
    ex gamma = 1/sqrt(1 - pow(v/c,2));
    ex mass_nonrel = gamma.series(v==0, 10);
    
    cout << "the relativistic mass increase with v is " << endl
         << mass_nonrel << endl;
    
    cout << "the inverse square of this series is " << endl
         << pow(mass_nonrel,-2).series(v==0, 10) << endl;
@}
@end example

Only calling the series method makes the last output simplify to
@math{1-v^2/c^2+O(v^10)}, without that call we would just have a long
series raised to the power @math{-2}.

@cindex Machin's formula
As another instructive application, let us calculate the numerical 
value of Archimedes' constant
@tex
$\pi$
@end tex
(for which there already exists the built-in constant @code{Pi}) 
using John Machin's amazing formula
@tex
$\pi=16$~atan~$\!\left(1 \over 5 \right)-4$~atan~$\!\left(1 \over 239 \right)$.
@end tex
@ifnottex
@math{Pi==16*atan(1/5)-4*atan(1/239)}.
@end ifnottex
This equation (and similar ones) were used for over 200 years for
computing digits of pi (see @cite{Pi Unleashed}).  We may expand the
arcus tangent around @code{0} and insert the fractions @code{1/5} and
@code{1/239}.  However, as we have seen, a series in GiNaC carries an
order term with it and the question arises what the system is supposed
to do when the fractions are plugged into that order term.  The solution
is to use the function @code{series_to_poly()} to simply strip the order
term off:

@example
#include <ginac/ginac.h>
using namespace GiNaC;

ex machin_pi(int degr)
@{
    symbol x;
    ex pi_expansion = series_to_poly(atan(x).series(x,degr));
    ex pi_approx = 16*pi_expansion.subs(x==numeric(1,5))
                   -4*pi_expansion.subs(x==numeric(1,239));
    return pi_approx;
@}

int main()
@{
    using std::cout;  // just for fun, another way of...
    using std::endl;  // ...dealing with this namespace std.
    ex pi_frac;
    for (int i=2; i<12; i+=2) @{
        pi_frac = machin_pi(i);
        cout << i << ":\t" << pi_frac << endl
             << "\t" << pi_frac.evalf() << endl;
    @}
    return 0;
@}
@end example

Note how we just called @code{.series(x,degr)} instead of
@code{.series(x==0,degr)}.  This is a simple shortcut for @code{ex}'s
method @code{series()}: if the first argument is a symbol the expression
is expanded in that symbol around point @code{0}.  When you run this
program, it will type out:

@example
2:      3804/1195
        3.1832635983263598326
4:      5359397032/1706489875
        3.1405970293260603143
6:      38279241713339684/12184551018734375
        3.141621029325034425
8:      76528487109180192540976/24359780855939418203125
        3.141591772182177295
10:     327853873402258685803048818236/104359128170408663038552734375
        3.1415926824043995174
@end example


@node Symmetrization, Built-in Functions, Series Expansion, Methods and Functions
@c    node-name, next, previous, up
@section Symmetrization
@cindex @code{symmetrize()}
@cindex @code{antisymmetrize()}
@cindex @code{symmetrize_cyclic()}

The three methods

@example
ex ex::symmetrize(const lst & l);
ex ex::antisymmetrize(const lst & l);
ex ex::symmetrize_cyclic(const lst & l);
@end example

symmetrize an expression by returning the sum over all symmetric,
antisymmetric or cyclic permutations of the specified list of objects,
weighted by the number of permutations.

The three additional methods

@example
ex ex::symmetrize();
ex ex::antisymmetrize();
ex ex::symmetrize_cyclic();
@end example

symmetrize or antisymmetrize an expression over its free indices.

Symmetrization is most useful with indexed expressions but can be used with
almost any kind of object (anything that is @code{subs()}able):

@example
@{
    idx i(symbol("i"), 3), j(symbol("j"), 3), k(symbol("k"), 3);
    symbol A("A"), B("B"), a("a"), b("b"), c("c");
                                           
    cout << indexed(A, i, j).symmetrize() << endl;
     // -> 1/2*A.j.i+1/2*A.i.j
    cout << indexed(A, i, j, k).antisymmetrize(lst(i, j)) << endl;
     // -> -1/2*A.j.i.k+1/2*A.i.j.k
    cout << lst(a, b, c).symmetrize_cyclic(lst(a, b, c)) << endl;
     // -> 1/3*@{a,b,c@}+1/3*@{b,c,a@}+1/3*@{c,a,b@}
@}
@end example

@node Built-in Functions, Multiple polylogarithms, Symmetrization, Methods and Functions
@c    node-name, next, previous, up
@section Predefined mathematical functions
@c
@subsection Overview

GiNaC contains the following predefined mathematical functions:

@cartouche
@multitable @columnfractions .30 .70
@item @strong{Name} @tab @strong{Function}
@item @code{abs(x)}
@tab absolute value
@cindex @code{abs()}
@item @code{csgn(x)}
@tab complex sign
@cindex @code{conjugate()}
@item @code{conjugate(x)}
@tab complex conjugation
@cindex @code{csgn()}
@item @code{sqrt(x)}
@tab square root (not a GiNaC function, rather an alias for @code{pow(x, numeric(1, 2))})
@cindex @code{sqrt()}
@item @code{sin(x)}
@tab sine
@cindex @code{sin()}
@item @code{cos(x)}
@tab cosine
@cindex @code{cos()}
@item @code{tan(x)}
@tab tangent
@cindex @code{tan()}
@item @code{asin(x)}
@tab inverse sine
@cindex @code{asin()}
@item @code{acos(x)}
@tab inverse cosine
@cindex @code{acos()}
@item @code{atan(x)}
@tab inverse tangent
@cindex @code{atan()}
@item @code{atan2(y, x)}
@tab inverse tangent with two arguments
@item @code{sinh(x)}
@tab hyperbolic sine
@cindex @code{sinh()}
@item @code{cosh(x)}
@tab hyperbolic cosine
@cindex @code{cosh()}
@item @code{tanh(x)}
@tab hyperbolic tangent
@cindex @code{tanh()}
@item @code{asinh(x)}
@tab inverse hyperbolic sine
@cindex @code{asinh()}
@item @code{acosh(x)}
@tab inverse hyperbolic cosine
@cindex @code{acosh()}
@item @code{atanh(x)}
@tab inverse hyperbolic tangent
@cindex @code{atanh()}
@item @code{exp(x)}
@tab exponential function
@cindex @code{exp()}
@item @code{log(x)}
@tab natural logarithm
@cindex @code{log()}
@item @code{Li2(x)}
@tab dilogarithm
@cindex @code{Li2()}
@item @code{Li(m, x)}
@tab classical polylogarithm as well as multiple polylogarithm
@cindex @code{Li()}
@item @code{S(n, p, x)}
@tab Nielsen's generalized polylogarithm
@cindex @code{S()}
@item @code{H(m, x)}
@tab harmonic polylogarithm
@cindex @code{H()}
@item @code{zeta(m)}
@tab Riemann's zeta function as well as multiple zeta value
@cindex @code{zeta()}
@item @code{zeta(m, s)}
@tab alternating Euler sum
@cindex @code{zeta()}
@item @code{zetaderiv(n, x)}
@tab derivatives of Riemann's zeta function
@item @code{tgamma(x)}
@tab gamma function
@cindex @code{tgamma()}
@cindex gamma function
@item @code{lgamma(x)}
@tab logarithm of gamma function
@cindex @code{lgamma()}
@item @code{beta(x, y)}
@tab beta function (@code{tgamma(x)*tgamma(y)/tgamma(x+y)})
@cindex @code{beta()}
@item @code{psi(x)}
@tab psi (digamma) function
@cindex @code{psi()}
@item @code{psi(n, x)}
@tab derivatives of psi function (polygamma functions)
@item @code{factorial(n)}
@tab factorial function @math{n!}
@cindex @code{factorial()}
@item @code{binomial(n, k)}
@tab binomial coefficients
@cindex @code{binomial()}
@item @code{Order(x)}
@tab order term function in truncated power series
@cindex @code{Order()}
@end multitable
@end cartouche

@cindex branch cut
For functions that have a branch cut in the complex plane GiNaC follows
the conventions for C++ as defined in the ANSI standard as far as
possible.  In particular: the natural logarithm (@code{log}) and the
square root (@code{sqrt}) both have their branch cuts running along the
negative real axis where the points on the axis itself belong to the
upper part (i.e. continuous with quadrant II).  The inverse
trigonometric and hyperbolic functions are not defined for complex
arguments by the C++ standard, however.  In GiNaC we follow the
conventions used by CLN, which in turn follow the carefully designed
definitions in the Common Lisp standard.  It should be noted that this
convention is identical to the one used by the C99 standard and by most
serious CAS.  It is to be expected that future revisions of the C++
standard incorporate these functions in the complex domain in a manner
compatible with C99.

@node Multiple polylogarithms, Complex Conjugation, Built-in Functions, Methods and Functions
@c    node-name, next, previous, up
@subsection Multiple polylogarithms

@cindex polylogarithm
@cindex Nielsen's generalized polylogarithm
@cindex harmonic polylogarithm
@cindex multiple zeta value
@cindex alternating Euler sum
@cindex multiple polylogarithm

The multiple polylogarithm is the most generic member of a family of functions,
to which others like the harmonic polylogarithm, Nielsen's generalized
polylogarithm and the multiple zeta value belong.
Everyone of these functions can also be written as a multiple polylogarithm with specific
parameters. This whole family of functions is therefore often referred to simply as
multiple polylogarithms, containing @code{Li}, @code{H}, @code{S} and @code{zeta}.

To facilitate the discussion of these functions we distinguish between indices and
arguments as parameters. In the table above indices are printed as @code{m}, @code{s},
@code{n} or @code{p}, whereas arguments are printed as @code{x}.

To define a @code{Li}, @code{H} or @code{zeta} with a depth greater than one, you have to
pass a GiNaC @code{lst} for the indices @code{m} and @code{s}, and in the case of @code{Li}
for the argument @code{x} as well.
Note that @code{Li} and @code{zeta} are polymorphic in this respect. They can stand in for
the classical polylogarithm and Riemann's zeta function (if depth is one), as well as for
the multiple polylogarithm and the multiple zeta value, respectively. Note also, that
GiNaC doesn't check whether the @code{lst}s for two parameters do have the same length.
It is up to the user to ensure this, otherwise evaluating will result in undefined behavior.

The functions print in LaTeX format as
@tex
${\rm Li\;\!}_{m_1,m_2,\ldots,m_k}(x_1,x_2,\ldots,x_k)$, 
@end tex
@tex
${\rm S}_{n,p}(x)$, 
@end tex
@tex
${\rm H\;\!}_{m_1,m_2,\ldots,m_k}(x)$ and 
@end tex
@tex
$\zeta(m_1,m_2,\ldots,m_k)$.
@end tex
If @code{zeta} is an alternating zeta sum, i.e. @code{zeta(m,s)}, the indices with negative sign
are printed with a line above, e.g.
@tex
$\zeta(5,\overline{2})$.
@end tex
The order of indices and arguments in the GiNaC @code{lst}s and in the output is the same.

Definitions and analytical as well as numerical properties of multiple polylogarithms
are too numerous to be covered here. Instead, the user is referred to the publications listed at the
end of this section. The implementation in GiNaC adheres to the definitions and conventions therein,
except for a few differences which will be explicitly stated in the following.

One difference is about the order of the indices and arguments. For GiNaC we adopt the convention
that the indices and arguments are understood to be in the same order as in which they appear in
the series representation. This means
@tex
${\rm Li\;\!}_{m_1,m_2,m_3}(x,1,1) = {\rm H\;\!}_{m_1,m_2,m_3}(x)$ and 
@end tex
@tex
${\rm Li\;\!}_{2,1}(1,1) = \zeta(2,1) = \zeta(3)$, but
@end tex
@tex
$\zeta(1,2)$ evaluates to infinity.
@end tex
So in comparison to the referenced publications the order of indices and arguments for @code{Li}
is reversed.

The functions only evaluate if the indices are integers greater than zero, except for the indices
@code{s} in @code{zeta} and @code{m} in @code{H}. Since @code{s} will be interpreted as the sequence
of signs for the corresponding indices @code{m}, it must contain 1 or -1, e.g.
@code{zeta(lst(3,4), lst(-1,1))} means
@tex
$\zeta(\overline{3},4)$.
@end tex
The definition of @code{H} allows indices to be 0, 1 or -1 (in expanded notation) or equally to
be any integer (in compact notation). With GiNaC expanded and compact notation can be mixed,
e.g. @code{lst(0,0,-1,0,1,0,0)}, @code{lst(0,0,-1,2,0,0)} and @code{lst(-3,2,0,0)} are equivalent as
indices. The anonymous evaluator @code{eval()} tries to reduce the functions, if possible, to
the least-generic multiple polylogarithm. If all arguments are unit, it returns @code{zeta}.
Arguments equal to zero get considered, too. Riemann's zeta function @code{zeta} (with depth one)
evaluates also for negative integers and positive even integers. For example:

@example
> Li(@{3,1@},@{x,1@});
S(2,2,x)
> H(@{-3,2@},1);
-zeta(@{3,2@},@{-1,-1@})
> S(3,1,1);
1/90*Pi^4
@end example

It is easy to tell for a given function into which other function it can be rewritten, may
it be a less-generic or a more-generic one, except for harmonic polylogarithms @code{H}
with negative indices or trailing zeros (the example above gives a hint). Signs can
quickly be messed up, for example. Therefore GiNaC offers a C++ function
@code{convert_H_to_Li()} to deal with the upgrade of a @code{H} to a multiple polylogarithm
@code{Li} (@code{eval()} already cares for the possible downgrade):

@example
> convert_H_to_Li(@{0,-2,-1,3@},x);
Li(@{3,1,3@},@{-x,1,-1@})
> convert_H_to_Li(@{2,-1,0@},x);
-Li(@{2,1@},@{x,-1@})*log(x)+2*Li(@{3,1@},@{x,-1@})+Li(@{2,2@},@{x,-1@})
@end example

Every function apart from the multiple polylogarithm @code{Li} can be numerically evaluated for
arbitrary real or complex arguments. @code{Li} only evaluates if for all arguments
@tex
$x_i$ the condition
@end tex
@tex
$x_1x_2\cdots x_i < 1$ holds.
@end tex

@example
> Digits=100;
100
> evalf(zeta(@{3,1,3,1@}));
0.005229569563530960100930652283899231589890420784634635522547448972148869544...
@end example

Note that the convention for arguments on the branch cut in GiNaC as stated above is
different from the one Remiddi and Vermaseren have chosen for the harmonic polylogarithm.

If a function evaluates to infinity, no exceptions are raised, but the function is returned
unevaluated, e.g.
@tex
$\zeta(1)$.
@end tex
In long expressions this helps a lot with debugging, because you can easily spot
the divergencies. But on the other hand, you have to make sure for yourself, that no illegal
cancellations of divergencies happen.

Useful publications:

@cite{Nested Sums, Expansion of Transcendental Functions and Multi-Scale Multi-Loop Integrals}, 
S.Moch, P.Uwer, S.Weinzierl, hep-ph/0110083

@cite{Harmonic Polylogarithms}, 
E.Remiddi, J.A.M.Vermaseren, Int.J.Mod.Phys. A15 (2000), pp. 725-754

@cite{Special Values of Multiple Polylogarithms}, 
J.Borwein, D.Bradley, D.Broadhurst, P.Lisonek, Trans.Amer.Math.Soc. 353/3 (2001), pp. 907-941

@node Complex Conjugation, Solving Linear Systems of Equations, Multiple polylogarithms, Methods and Functions
@c    node-name, next, previous, up
@section Complex Conjugation
@c
@cindex @code{conjugate()}

The method

@example
ex ex::conjugate();
@end example

returns the complex conjugate of the expression. For all built-in functions and objects the
conjugation gives the expected results:

@example
@{
    varidx a(symbol("a"), 4), b(symbol("b"), 4);
    symbol x("x");
    realsymbol y("y");
                                           
    cout << (3*I*x*y + sin(2*Pi*I*y)).conjugate() << endl;
     // -> -3*I*conjugate(x)*y+sin(-2*I*Pi*y)
    cout << (dirac_gamma(a)*dirac_gamma(b)*dirac_gamma5()).conjugate() << endl;
     // -> -gamma5*gamma~b*gamma~a
@}
@end example

For symbols in the complex domain the conjugation can not be evaluated and the GiNaC function
@code{conjugate} is returned. GiNaC functions conjugate by applying the conjugation to their
arguments. This is the default strategy. If you want to define your own functions and want to
change this behavior, you have to supply a specialized conjugation method for your function
(see @ref{Symbolic functions} and the GiNaC source-code for @code{abs} as an example).

@node Solving Linear Systems of Equations, Input/Output, Complex Conjugation, Methods and Functions
@c    node-name, next, previous, up
@section Solving Linear Systems of Equations
@cindex @code{lsolve()}

The function @code{lsolve()} provides a convenient wrapper around some
matrix operations that comes in handy when a system of linear equations
needs to be solved:

@example
ex lsolve(const ex &eqns, const ex &symbols, unsigned options=solve_algo::automatic);
@end example

Here, @code{eqns} is a @code{lst} of equalities (i.e. class
@code{relational}) while @code{symbols} is a @code{lst} of
indeterminates.  (@xref{The Class Hierarchy}, for an exposition of class
@code{lst}).

It returns the @code{lst} of solutions as an expression.  As an example,
let us solve the two equations @code{a*x+b*y==3} and @code{x-y==b}:

@example
@{
    symbol a("a"), b("b"), x("x"), y("y");
    lst eqns, vars;
    eqns = a*x+b*y==3, x-y==b;
    vars = x, y;
    cout << lsolve(eqns, vars) << endl;
     // -> @{x==(3+b^2)/(b+a),y==(3-b*a)/(b+a)@}
@end example

When the linear equations @code{eqns} are underdetermined, the solution
will contain one or more tautological entries like @code{x==x},
depending on the rank of the system.  When they are overdetermined, the
solution will be an empty @code{lst}.  Note the third optional parameter
to @code{lsolve()}: it accepts the same parameters as
@code{matrix::solve()}.  This is because @code{lsolve} is just a wrapper
around that method.


@node Input/Output, Extending GiNaC, Solving Linear Systems of Equations, Methods and Functions
@c    node-name, next, previous, up
@section Input and output of expressions
@cindex I/O

@subsection Expression output
@cindex printing
@cindex output of expressions

Expressions can simply be written to any stream:

@example
@{
    symbol x("x");
    ex e = 4.5*I+pow(x,2)*3/2;
    cout << e << endl;    // prints '4.5*I+3/2*x^2'
    // ...
@end example

The default output format is identical to the @command{ginsh} input syntax and
to that used by most computer algebra systems, but not directly pastable
into a GiNaC C++ program (note that in the above example, @code{pow(x,2)}
is printed as @samp{x^2}).

It is possible to print expressions in a number of different formats with
a set of stream manipulators;

@example
std::ostream & dflt(std::ostream & os);
std::ostream & latex(std::ostream & os);
std::ostream & tree(std::ostream & os);
std::ostream & csrc(std::ostream & os);
std::ostream & csrc_float(std::ostream & os);
std::ostream & csrc_double(std::ostream & os);
std::ostream & csrc_cl_N(std::ostream & os);
std::ostream & index_dimensions(std::ostream & os);
std::ostream & no_index_dimensions(std::ostream & os);
@end example

The @code{tree}, @code{latex} and @code{csrc} formats are also available in
@command{ginsh} via the @code{print()}, @code{print_latex()} and
@code{print_csrc()} functions, respectively.

@cindex @code{dflt}
All manipulators affect the stream state permanently. To reset the output
format to the default, use the @code{dflt} manipulator:

@example
    // ...
    cout << latex;            // all output to cout will be in LaTeX format from now on
    cout << e << endl;        // prints '4.5 i+\frac@{3@}@{2@} x^@{2@}'
    cout << sin(x/2) << endl; // prints '\sin(\frac@{1@}@{2@} x)'
    cout << dflt;             // revert to default output format
    cout << e << endl;        // prints '4.5*I+3/2*x^2'
    // ...
@end example

If you don't want to affect the format of the stream you're working with,
you can output to a temporary @code{ostringstream} like this:

@example
    // ...
    ostringstream s;
    s << latex << e;         // format of cout remains unchanged
    cout << s.str() << endl; // prints '4.5 i+\frac@{3@}@{2@} x^@{2@}'
    // ...
@end example

@cindex @code{csrc}
@cindex @code{csrc_float}
@cindex @code{csrc_double}
@cindex @code{csrc_cl_N}
The @code{csrc} (an alias for @code{csrc_double}), @code{csrc_float},
@code{csrc_double} and @code{csrc_cl_N} manipulators set the output to a
format that can be directly used in a C or C++ program. The three possible
formats select the data types used for numbers (@code{csrc_cl_N} uses the
classes provided by the CLN library):

@example
    // ...
    cout << "f = " << csrc_float << e << ";\n";
    cout << "d = " << csrc_double << e << ";\n";
    cout << "n = " << csrc_cl_N << e << ";\n";
    // ...
@end example

The above example will produce (note the @code{x^2} being converted to
@code{x*x}):

@example
f = (3.0/2.0)*(x*x)+std::complex<float>(0.0,4.5000000e+00);
d = (3.0/2.0)*(x*x)+std::complex<double>(0.0,4.5000000000000000e+00);
n = cln::cl_RA("3/2")*(x*x)+cln::complex(cln::cl_I("0"),cln::cl_F("4.5_17"));
@end example

@cindex @code{tree}
The @code{tree} manipulator allows dumping the internal structure of an
expression for debugging purposes:

@example
    // ...
    cout << tree << e;
@}
@end example

produces

@example
add, hash=0x0, flags=0x3, nops=2
    power, hash=0x0, flags=0x3, nops=2
        x (symbol), serial=0, hash=0xc8d5bcdd, flags=0xf
        2 (numeric), hash=0x6526b0fa, flags=0xf
    3/2 (numeric), hash=0xf9828fbd, flags=0xf
    -----
    overall_coeff
    4.5L0i (numeric), hash=0xa40a97e0, flags=0xf
    =====
@end example

@cindex @code{latex}
The @code{latex} output format is for LaTeX parsing in mathematical mode.
It is rather similar to the default format but provides some braces needed
by LaTeX for delimiting boxes and also converts some common objects to
conventional LaTeX names. It is possible to give symbols a special name for
LaTeX output by supplying it as a second argument to the @code{symbol}
constructor.

For example, the code snippet

@example
@{
    symbol x("x", "\\circ");
    ex e = lgamma(x).series(x==0,3);
    cout << latex << e << endl;
@}
@end example

will print

@example
    @{(-\ln(\circ))@}+@{(-\gamma_E)@} \circ+@{(\frac@{1@}@{12@} \pi^@{2@})@} \circ^@{2@}+\mathcal@{O@}(\circ^@{3@})
@end example

@cindex @code{index_dimensions}
@cindex @code{no_index_dimensions}
Index dimensions are normally hidden in the output. To make them visible, use
the @code{index_dimensions} manipulator. The dimensions will be written in
square brackets behind each index value in the default and LaTeX output
formats:

@example
@{
    symbol x("x"), y("y");
    varidx mu(symbol("mu"), 4), nu(symbol("nu"), 4);
    ex e = indexed(x, mu) * indexed(y, nu);

    cout << e << endl;
     // prints 'x~mu*y~nu'
    cout << index_dimensions << e << endl;
     // prints 'x~mu[4]*y~nu[4]'
    cout << no_index_dimensions << e << endl;
     // prints 'x~mu*y~nu'
@}
@end example


@cindex Tree traversal
If you need any fancy special output format, e.g. for interfacing GiNaC
with other algebra systems or for producing code for different
programming languages, you can always traverse the expression tree yourself:

@example
static void my_print(const ex & e)
@{
    if (is_a<function>(e))
        cout << ex_to<function>(e).get_name();
    else
        cout << ex_to<basic>(e).class_name();
    cout << "(";
    size_t n = e.nops();
    if (n)
        for (size_t i=0; i<n; i++) @{
            my_print(e.op(i));
            if (i != n-1)
                cout << ",";
        @}
    else
        cout << e;
    cout << ")";
@}

int main()
@{
    my_print(pow(3, x) - 2 * sin(y / Pi)); cout << endl;
    return 0;
@}
@end example

This will produce

@example
add(power(numeric(3),symbol(x)),mul(sin(mul(power(constant(Pi),numeric(-1)),
symbol(y))),numeric(-2)))
@end example

If you need an output format that makes it possible to accurately
reconstruct an expression by feeding the output to a suitable parser or
object factory, you should consider storing the expression in an
@code{archive} object and reading the object properties from there.
See the section on archiving for more information.


@subsection Expression input
@cindex input of expressions

GiNaC provides no way to directly read an expression from a stream because
you will usually want the user to be able to enter something like @samp{2*x+sin(y)}
and have the @samp{x} and @samp{y} correspond to the symbols @code{x} and
@code{y} you defined in your program and there is no way to specify the
desired symbols to the @code{>>} stream input operator.

Instead, GiNaC lets you construct an expression from a string, specifying the
list of symbols to be used:

@example
@{
    symbol x("x"), y("y");
    ex e("2*x+sin(y)", lst(x, y));
@}
@end example

The input syntax is the same as that used by @command{ginsh} and the stream
output operator @code{<<}. The symbols in the string are matched by name to
the symbols in the list and if GiNaC encounters a symbol not specified in
the list it will throw an exception.

With this constructor, it's also easy to implement interactive GiNaC programs:

@example
#include <iostream>
#include <string>
#include <stdexcept>
#include <ginac/ginac.h>
using namespace std;
using namespace GiNaC;

int main()
@{
    symbol x("x");
    string s;

    cout << "Enter an expression containing 'x': ";
    getline(cin, s);

    try @{
        ex e(s, lst(x));
        cout << "The derivative of " << e << " with respect to x is ";
        cout << e.diff(x) << ".\n";
    @} catch (exception &p) @{
        cerr << p.what() << endl;
    @}
@}
@end example


@subsection Archiving
@cindex @code{archive} (class)
@cindex archiving

GiNaC allows creating @dfn{archives} of expressions which can be stored
to or retrieved from files. To create an archive, you declare an object
of class @code{archive} and archive expressions in it, giving each
expression a unique name:

@example
#include <fstream>
using namespace std;
#include <ginac/ginac.h>
using namespace GiNaC;

int main()
@{
    symbol x("x"), y("y"), z("z");

    ex foo = sin(x + 2*y) + 3*z + 41;
    ex bar = foo + 1;

    archive a;
    a.archive_ex(foo, "foo");
    a.archive_ex(bar, "the second one");
    // ...
@end example

The archive can then be written to a file:

@example
    // ...
    ofstream out("foobar.gar");
    out << a;
    out.close();
    // ...
@end example

The file @file{foobar.gar} contains all information that is needed to
reconstruct the expressions @code{foo} and @code{bar}.

@cindex @command{viewgar}
The tool @command{viewgar} that comes with GiNaC can be used to view
the contents of GiNaC archive files:

@example
$ viewgar foobar.gar
foo = 41+sin(x+2*y)+3*z
the second one = 42+sin(x+2*y)+3*z
@end example

The point of writing archive files is of course that they can later be
read in again:

@example
    // ...
    archive a2;
    ifstream in("foobar.gar");
    in >> a2;
    // ...
@end example

And the stored expressions can be retrieved by their name:

@example
    // ...
    lst syms;
    syms = x, y;

    ex ex1 = a2.unarchive_ex(syms, "foo");
    ex ex2 = a2.unarchive_ex(syms, "the second one");

    cout << ex1 << endl;              // prints "41+sin(x+2*y)+3*z"
    cout << ex2 << endl;              // prints "42+sin(x+2*y)+3*z"
    cout << ex1.subs(x == 2) << endl; // prints "41+sin(2+2*y)+3*z"
@}
@end example

Note that you have to supply a list of the symbols which are to be inserted
in the expressions. Symbols in archives are stored by their name only and
if you don't specify which symbols you have, unarchiving the expression will
create new symbols with that name. E.g. if you hadn't included @code{x} in
the @code{syms} list above, the @code{ex1.subs(x == 2)} statement would
have had no effect because the @code{x} in @code{ex1} would have been a
different symbol than the @code{x} which was defined at the beginning of
the program, although both would appear as @samp{x} when printed.

You can also use the information stored in an @code{archive} object to
output expressions in a format suitable for exact reconstruction. The
@code{archive} and @code{archive_node} classes have a couple of member
functions that let you access the stored properties:

@example
static void my_print2(const archive_node & n)
@{
    string class_name;
    n.find_string("class", class_name);
    cout << class_name << "(";

    archive_node::propinfovector p;
    n.get_properties(p);

    size_t num = p.size();
    for (size_t i=0; i<num; i++) @{
        const string &name = p[i].name;
        if (name == "class")
            continue;
        cout << name << "=";

        unsigned count = p[i].count;
        if (count > 1)
            cout << "@{";

        for (unsigned j=0; j<count; j++) @{
            switch (p[i].type) @{
                case archive_node::PTYPE_BOOL: @{
                    bool x;
                    n.find_bool(name, x, j);
                    cout << (x ? "true" : "false");
                    break;
                @}
                case archive_node::PTYPE_UNSIGNED: @{
                    unsigned x;
                    n.find_unsigned(name, x, j);
                    cout << x;
                    break;
                @}
                case archive_node::PTYPE_STRING: @{
                    string x;
                    n.find_string(name, x, j);
                    cout << '\"' << x << '\"';
                    break;
                @}
                case archive_node::PTYPE_NODE: @{
                    const archive_node &x = n.find_ex_node(name, j);
                    my_print2(x);
                    break;
                @}
            @}

            if (j != count-1)
                cout << ",";
        @}

        if (count > 1)
            cout << "@}";

        if (i != num-1)
            cout << ",";
    @}

    cout << ")";
@}

int main()
@{
    ex e = pow(2, x) - y;
    archive ar(e, "e");
    my_print2(ar.get_top_node(0)); cout << endl;
    return 0;
@}
@end example

This will produce:

@example
add(rest=@{power(basis=numeric(number="2"),exponent=symbol(name="x")),
symbol(name="y")@},coeff=@{numeric(number="1"),numeric(number="-1")@},
overall_coeff=numeric(number="0"))
@end example

Be warned, however, that the set of properties and their meaning for each
class may change between GiNaC versions.


@node Extending GiNaC, What does not belong into GiNaC, Input/Output, Top
@c    node-name, next, previous, up
@chapter Extending GiNaC

By reading so far you should have gotten a fairly good understanding of
GiNaC's design patterns.  From here on you should start reading the
sources.  All we can do now is issue some recommendations how to tackle
GiNaC's many loose ends in order to fulfill everybody's dreams.  If you
develop some useful extension please don't hesitate to contact the GiNaC
authors---they will happily incorporate them into future versions.

@menu
* What does not belong into GiNaC::  What to avoid.
* Symbolic functions::               Implementing symbolic functions.
* Printing::                         Adding new output formats.
* Structures::                       Defining new algebraic classes (the easy way).
* Adding classes::                   Defining new algebraic classes (the hard way).
@end menu


@node What does not belong into GiNaC, Symbolic functions, Extending GiNaC, Extending GiNaC
@c    node-name, next, previous, up
@section What doesn't belong into GiNaC

@cindex @command{ginsh}
First of all, GiNaC's name must be read literally.  It is designed to be
a library for use within C++.  The tiny @command{ginsh} accompanying
GiNaC makes this even more clear: it doesn't even attempt to provide a
language.  There are no loops or conditional expressions in
@command{ginsh}, it is merely a window into the library for the
programmer to test stuff (or to show off).  Still, the design of a
complete CAS with a language of its own, graphical capabilities and all
this on top of GiNaC is possible and is without doubt a nice project for
the future.

There are many built-in functions in GiNaC that do not know how to
evaluate themselves numerically to a precision declared at runtime
(using @code{Digits}).  Some may be evaluated at certain points, but not
generally.  This ought to be fixed.  However, doing numerical
computations with GiNaC's quite abstract classes is doomed to be
inefficient.  For this purpose, the underlying foundation classes
provided by CLN are much better suited.


@node Symbolic functions, Printing, What does not belong into GiNaC, Extending GiNaC
@c    node-name, next, previous, up
@section Symbolic functions

The easiest and most instructive way to start extending GiNaC is probably to
create your own symbolic functions. These are implemented with the help of
two preprocessor macros:

@cindex @code{DECLARE_FUNCTION}
@cindex @code{REGISTER_FUNCTION}
@example
DECLARE_FUNCTION_<n>P(<name>)
REGISTER_FUNCTION(<name>, <options>)
@end example

The @code{DECLARE_FUNCTION} macro will usually appear in a header file. It
declares a C++ function with the given @samp{name} that takes exactly @samp{n}
parameters of type @code{ex} and returns a newly constructed GiNaC
@code{function} object that represents your function.

The @code{REGISTER_FUNCTION} macro implements the function. It must be passed
the same @samp{name} as the respective @code{DECLARE_FUNCTION} macro, and a
set of options that associate the symbolic function with C++ functions you
provide to implement the various methods such as evaluation, derivative,
series expansion etc. They also describe additional attributes the function
might have, such as symmetry and commutation properties, and a name for
LaTeX output. Multiple options are separated by the member access operator
@samp{.} and can be given in an arbitrary order.

(By the way: in case you are worrying about all the macros above we can
assure you that functions are GiNaC's most macro-intense classes. We have
done our best to avoid macros where we can.)

@subsection A minimal example

Here is an example for the implementation of a function with two arguments
that is not further evaluated:

@example
DECLARE_FUNCTION_2P(myfcn)

REGISTER_FUNCTION(myfcn, dummy())
@end example

Any code that has seen the @code{DECLARE_FUNCTION} line can use @code{myfcn()}
in algebraic expressions:

@example
@{
    ...
    symbol x("x");
    ex e = 2*myfcn(42, 1+3*x) - x;
    cout << e << endl;
     // prints '2*myfcn(42,1+3*x)-x'
    ...
@}
@end example

The @code{dummy()} option in the @code{REGISTER_FUNCTION} line signifies
"no options". A function with no options specified merely acts as a kind of
container for its arguments. It is a pure "dummy" function with no associated
logic (which is, however, sometimes perfectly sufficient).

Let's now have a look at the implementation of GiNaC's cosine function for an
example of how to make an "intelligent" function.

@subsection The cosine function

The GiNaC header file @file{inifcns.h} contains the line

@example
DECLARE_FUNCTION_1P(cos)
@end example

which declares to all programs using GiNaC that there is a function @samp{cos}
that takes one @code{ex} as an argument. This is all they need to know to use
this function in expressions.

The implementation of the cosine function is in @file{inifcns_trans.cpp}. Here
is its @code{REGISTER_FUNCTION} line:

@example
REGISTER_FUNCTION(cos, eval_func(cos_eval).
                       evalf_func(cos_evalf).
                       derivative_func(cos_deriv).
                       latex_name("\\cos"));
@end example

There are four options defined for the cosine function. One of them
(@code{latex_name}) gives the function a proper name for LaTeX output; the
other three indicate the C++ functions in which the "brains" of the cosine
function are defined.

@cindex @code{hold()}
@cindex evaluation
The @code{eval_func()} option specifies the C++ function that implements
the @code{eval()} method, GiNaC's anonymous evaluator. This function takes
the same number of arguments as the associated symbolic function (one in this
case) and returns the (possibly transformed or in some way simplified)
symbolically evaluated function (@xref{Automatic evaluation}, for a description
of the automatic evaluation process). If no (further) evaluation is to take
place, the @code{eval_func()} function must return the original function
with @code{.hold()}, to avoid a potential infinite recursion. If your
symbolic functions produce a segmentation fault or stack overflow when
using them in expressions, you are probably missing a @code{.hold()}
somewhere.

The @code{eval_func()} function for the cosine looks something like this
(actually, it doesn't look like this at all, but it should give you an idea
what is going on):

@example
static ex cos_eval(const ex & x)
@{
    if ("x is a multiple of 2*Pi")
        return 1;
    else if ("x is a multiple of Pi")
        return -1;
    else if ("x is a multiple of Pi/2")
        return 0;
    // more rules...

    else if ("x has the form 'acos(y)'")
        return y;
    else if ("x has the form 'asin(y)'")
        return sqrt(1-y^2);
    // more rules...

    else
        return cos(x).hold();
@}
@end example

This function is called every time the cosine is used in a symbolic expression:

@example
@{
    ...
    e = cos(Pi);
     // this calls cos_eval(Pi), and inserts its return value into
     // the actual expression
    cout << e << endl;
     // prints '-1'
    ...
@}
@end example

In this way, @code{cos(4*Pi)} automatically becomes @math{1},
@code{cos(asin(a+b))} becomes @code{sqrt(1-(a+b)^2)}, etc. If no reasonable
symbolic transformation can be done, the unmodified function is returned
with @code{.hold()}.

GiNaC doesn't automatically transform @code{cos(2)} to @samp{-0.416146...}.
The user has to call @code{evalf()} for that. This is implemented in a
different function:

@example
static ex cos_evalf(const ex & x)
@{
    if (is_a<numeric>(x))
        return cos(ex_to<numeric>(x));
    else
        return cos(x).hold();
@}
@end example

Since we are lazy we defer the problem of numeric evaluation to somebody else,
in this case the @code{cos()} function for @code{numeric} objects, which in
turn hands it over to the @code{cos()} function in CLN. The @code{.hold()}
isn't really needed here, but reminds us that the corresponding @code{eval()}
function would require it in this place.

Differentiation will surely turn up and so we need to tell @code{cos}
what its first derivative is (higher derivatives, @code{.diff(x,3)} for
instance, are then handled automatically by @code{basic::diff} and
@code{ex::diff}):

@example
static ex cos_deriv(const ex & x, unsigned diff_param)
@{
    return -sin(x);
@}
@end example

@cindex product rule
The second parameter is obligatory but uninteresting at this point.  It
specifies which parameter to differentiate in a partial derivative in
case the function has more than one parameter, and its main application
is for correct handling of the chain rule.

An implementation of the series expansion is not needed for @code{cos()} as
it doesn't have any poles and GiNaC can do Taylor expansion by itself (as
long as it knows what the derivative of @code{cos()} is). @code{tan()}, on
the other hand, does have poles and may need to do Laurent expansion:

@example
static ex tan_series(const ex & x, const relational & rel,
                     int order, unsigned options)
@{
    // Find the actual expansion point
    const ex x_pt = x.subs(rel);

    if ("x_pt is not an odd multiple of Pi/2")
        throw do_taylor();  // tell function::series() to do Taylor expansion

    // On a pole, expand sin()/cos()
    return (sin(x)/cos(x)).series(rel, order+2, options);
@}
@end example

The @code{series()} implementation of a function @emph{must} return a
@code{pseries} object, otherwise your code will crash.

@subsection Function options

GiNaC functions understand several more options which are always
specified as @code{.option(params)}. None of them are required, but you
need to specify at least one option to @code{REGISTER_FUNCTION()}. There
is a do-nothing option called @code{dummy()} which you can use to define
functions without any special options.

@example
eval_func(<C++ function>)
evalf_func(<C++ function>)
derivative_func(<C++ function>)
series_func(<C++ function>)
conjugate_func(<C++ function>)
@end example

These specify the C++ functions that implement symbolic evaluation,
numeric evaluation, partial derivatives, and series expansion, respectively.
They correspond to the GiNaC methods @code{eval()}, @code{evalf()},
@code{diff()} and @code{series()}.

The @code{eval_func()} function needs to use @code{.hold()} if no further
automatic evaluation is desired or possible.

If no @code{series_func()} is given, GiNaC defaults to simple Taylor
expansion, which is correct if there are no poles involved. If the function
has poles in the complex plane, the @code{series_func()} needs to check
whether the expansion point is on a pole and fall back to Taylor expansion
if it isn't. Otherwise, the pole usually needs to be regularized by some
suitable transformation.

@example
latex_name(const string & n)
@end example

specifies the LaTeX code that represents the name of the function in LaTeX
output. The default is to put the function name in an @code{\mbox@{@}}.

@example
do_not_evalf_params()
@end example

This tells @code{evalf()} to not recursively evaluate the parameters of the
function before calling the @code{evalf_func()}.

@example
set_return_type(unsigned return_type, unsigned return_type_tinfo)
@end example

This allows you to explicitly specify the commutation properties of the
function (@xref{Non-commutative objects}, for an explanation of
(non)commutativity in GiNaC). For example, you can use
@code{set_return_type(return_types::noncommutative, TINFO_matrix)} to make
GiNaC treat your function like a matrix. By default, functions inherit the
commutation properties of their first argument.

@example
set_symmetry(const symmetry & s)
@end example

specifies the symmetry properties of the function with respect to its
arguments. @xref{Indexed objects}, for an explanation of symmetry
specifications. GiNaC will automatically rearrange the arguments of
symmetric functions into a canonical order.

Sometimes you may want to have finer control over how functions are
displayed in the output. For example, the @code{abs()} function prints
itself as @samp{abs(x)} in the default output format, but as @samp{|x|}
in LaTeX mode, and @code{fabs(x)} in C source output. This is achieved
with the

@example
print_func<C>(<C++ function>)
@end example

option which is explained in the next section.


@node Printing, Structures, Symbolic functions, Extending GiNaC
@c    node-name, next, previous, up
@section GiNaC's expression output system

GiNaC allows the output of expressions in a variety of different formats
(@pxref{Input/Output}). This section will explain how expression output
is implemented internally, and how to define your own output formats or
change the output format of built-in algebraic objects. You will also want
to read this section if you plan to write your own algebraic classes or
functions.

@cindex @code{print_context} (class)
@cindex @code{print_dflt} (class)
@cindex @code{print_latex} (class)
@cindex @code{print_tree} (class)
@cindex @code{print_csrc} (class)
All the different output formats are represented by a hierarchy of classes
rooted in the @code{print_context} class, defined in the @file{print.h}
header file:

@table @code
@item print_dflt
the default output format
@item print_latex
output in LaTeX mathematical mode
@item print_tree
a dump of the internal expression structure (for debugging)
@item print_csrc
the base class for C source output
@item print_csrc_float
C source output using the @code{float} type
@item print_csrc_double
C source output using the @code{double} type
@item print_csrc_cl_N
C source output using CLN types
@end table

The @code{print_context} base class provides two public data members:

@example
class print_context
@{
    ...
public:
    std::ostream & s;
    unsigned options;
@};
@end example

@code{s} is a reference to the stream to output to, while @code{options}
holds flags and modifiers. Currently, there is only one flag defined:
@code{print_options::print_index_dimensions} instructs the @code{idx} class
to print the index dimension which is normally hidden.

When you write something like @code{std::cout << e}, where @code{e} is
an object of class @code{ex}, GiNaC will construct an appropriate
@code{print_context} object (of a class depending on the selected output
format), fill in the @code{s} and @code{options} members, and call

@cindex @code{print()}
@example
void ex::print(const print_context & c, unsigned level = 0) const;
@end example

which in turn forwards the call to the @code{print()} method of the
top-level algebraic object contained in the expression.

Unlike other methods, GiNaC classes don't usually override their
@code{print()} method to implement expression output. Instead, the default
implementation @code{basic::print(c, level)} performs a run-time double
dispatch to a function selected by the dynamic type of the object and the
passed @code{print_context}. To this end, GiNaC maintains a separate method
table for each class, similar to the virtual function table used for ordinary
(single) virtual function dispatch.

The method table contains one slot for each possible @code{print_context}
type, indexed by the (internally assigned) serial number of the type. Slots
may be empty, in which case GiNaC will retry the method lookup with the
@code{print_context} object's parent class, possibly repeating the process
until it reaches the @code{print_context} base class. If there's still no
method defined, the method table of the algebraic object's parent class
is consulted, and so on, until a matching method is found (eventually it
will reach the combination @code{basic/print_context}, which prints the
object's class name enclosed in square brackets).

You can think of the print methods of all the different classes and output
formats as being arranged in a two-dimensional matrix with one axis listing
the algebraic classes and the other axis listing the @code{print_context}
classes.

Subclasses of @code{basic} can, of course, also overload @code{basic::print()}
to implement printing, but then they won't get any of the benefits of the
double dispatch mechanism (such as the ability for derived classes to
inherit only certain print methods from its parent, or the replacement of
methods at run-time).

@subsection Print methods for classes

The method table for a class is set up either in the definition of the class,
by passing the appropriate @code{print_func<C>()} option to
@code{GINAC_IMPLEMENT_REGISTERED_CLASS_OPT()} (@xref{Adding classes}, for
an example), or at run-time using @code{set_print_func<T, C>()}. The latter
can also be used to override existing methods dynamically.

The argument to @code{print_func<C>()} and @code{set_print_func<T, C>()} can
be a member function of the class (or one of its parent classes), a static
member function, or an ordinary (global) C++ function. The @code{C} template
parameter specifies the appropriate @code{print_context} type for which the
method should be invoked, while, in the case of @code{set_print_func<>()}, the
@code{T} parameter specifies the algebraic class (for @code{print_func<>()},
the class is the one being implemented by
@code{GINAC_IMPLEMENT_REGISTERED_CLASS_OPT}).

For print methods that are member functions, their first argument must be of
a type convertible to a @code{const C &}, and the second argument must be an
@code{unsigned}.

For static members and global functions, the first argument must be of a type
convertible to a @code{const T &}, the second argument must be of a type
convertible to a @code{const C &}, and the third argument must be an
@code{unsigned}. A global function will, of course, not have access to
private and protected members of @code{T}.

The @code{unsigned} argument of the print methods (and of @code{ex::print()}
and @code{basic::print()}) is used for proper parenthesizing of the output
(and by @code{print_tree} for proper indentation). It can be used for similar
purposes if you write your own output formats.

The explanations given above may seem complicated, but in practice it's
really simple, as shown in the following example. Suppose that we want to
display exponents in LaTeX output not as superscripts but with little
upwards-pointing arrows. This can be achieved in the following way:

@example
void my_print_power_as_latex(const power & p,
                             const print_latex & c,
                             unsigned level)
@{
    // get the precedence of the 'power' class
    unsigned power_prec = p.precedence();

    // if the parent operator has the same or a higher precedence
    // we need parentheses around the power
    if (level >= power_prec)
        c.s << '(';

    // print the basis and exponent, each enclosed in braces, and
    // separated by an uparrow
    c.s << '@{';
    p.op(0).print(c, power_prec);
    c.s << "@}\\uparrow@{";
    p.op(1).print(c, power_prec);
    c.s << '@}';

    // don't forget the closing parenthesis
    if (level >= power_prec)
        c.s << ')';
@}
                                                                                
int main()
@{
    // a sample expression
    symbol x("x"), y("y");
    ex e = -3*pow(x, 3)*pow(y, -2) + pow(x+y, 2) - 1;

    // switch to LaTeX mode
    cout << latex;

    // this prints "-1+@{(y+x)@}^@{2@}-3 \frac@{x^@{3@}@}@{y^@{2@}@}"
    cout << e << endl;

    // now we replace the method for the LaTeX output of powers with
    // our own one
    set_print_func<power, print_latex>(my_print_power_as_latex);

    // this prints "-1+@{@{(y+x)@}@}\uparrow@{2@}-3 \frac@{@{x@}\uparrow@{3@}@}@{@{y@}\uparrow@{2@}@}"
    cout << e << endl;
@}
@end example

Some notes:

@itemize

@item
The first argument of @code{my_print_power_as_latex} could also have been
a @code{const basic &}, the second one a @code{const print_context &}.

@item
The above code depends on @code{mul} objects converting their operands to
@code{power} objects for the purpose of printing.

@item
The output of products including negative powers as fractions is also
controlled by the @code{mul} class.

@item
The @code{power/print_latex} method provided by GiNaC prints square roots
using @code{\sqrt}, but the above code doesn't.

@end itemize

It's not possible to restore a method table entry to its previous or default
value. Once you have called @code{set_print_func()}, you can only override
it with another call to @code{set_print_func()}, but you can't easily go back
to the default behavior again (you can, of course, dig around in the GiNaC
sources, find the method that is installed at startup
(@code{power::do_print_latex} in this case), and @code{set_print_func} that
one; that is, after you circumvent the C++ member access control@dots{}).

@subsection Print methods for functions

Symbolic functions employ a print method dispatch mechanism similar to the
one used for classes. The methods are specified with @code{print_func<C>()}
function options. If you don't specify any special print methods, the function
will be printed with its name (or LaTeX name, if supplied), followed by a
comma-separated list of arguments enclosed in parentheses.

For example, this is what GiNaC's @samp{abs()} function is defined like:

@example
static ex abs_eval(const ex & arg) @{ ... @}
static ex abs_evalf(const ex & arg) @{ ... @}
                                                                                
static void abs_print_latex(const ex & arg, const print_context & c)
@{
    c.s << "@{|"; arg.print(c); c.s << "|@}";
@}
                                                                                
static void abs_print_csrc_float(const ex & arg, const print_context & c)
@{
    c.s << "fabs("; arg.print(c); c.s << ")";
@}
                                                                                
REGISTER_FUNCTION(abs, eval_func(abs_eval).
                       evalf_func(abs_evalf).
                       print_func<print_latex>(abs_print_latex).
                       print_func<print_csrc_float>(abs_print_csrc_float).
                       print_func<print_csrc_double>(abs_print_csrc_float));
@end example

This will display @samp{abs(x)} as @samp{|x|} in LaTeX mode and @code{fabs(x)}
in non-CLN C source output, but as @code{abs(x)} in all other formats.

There is currently no equivalent of @code{set_print_func()} for functions.

@subsection Adding new output formats

Creating a new output format involves subclassing @code{print_context},
which is somewhat similar to adding a new algebraic class
(@pxref{Adding classes}). There is a macro @code{GINAC_DECLARE_PRINT_CONTEXT}
that needs to go into the class definition, and a corresponding macro
@code{GINAC_IMPLEMENT_PRINT_CONTEXT} that has to appear at global scope.
Every @code{print_context} class needs to provide a default constructor
and a constructor from an @code{std::ostream} and an @code{unsigned}
options value.

Here is an example for a user-defined @code{print_context} class:

@example
class print_myformat : public print_dflt
@{
    GINAC_DECLARE_PRINT_CONTEXT(print_myformat, print_dflt)
public:
    print_myformat(std::ostream & os, unsigned opt = 0)
     : print_dflt(os, opt) @{@}
@};

print_myformat::print_myformat() : print_dflt(std::cout) @{@}

GINAC_IMPLEMENT_PRINT_CONTEXT(print_myformat, print_dflt)
@end example

That's all there is to it. None of the actual expression output logic is
implemented in this class. It merely serves as a selector for choosing
a particular format. The algorithms for printing expressions in the new
format are implemented as print methods, as described above.

@code{print_myformat} is a subclass of @code{print_dflt}, so it behaves
exactly like GiNaC's default output format:

@example
@{
    symbol x("x");
    ex e = pow(x, 2) + 1;

    // this prints "1+x^2"
    cout << e << endl;
    
    // this also prints "1+x^2"
    e.print(print_myformat()); cout << endl;

    ...
@}
@end example

To fill @code{print_myformat} with life, we need to supply appropriate
print methods with @code{set_print_func()}, like this:

@example
// This prints powers with '**' instead of '^'. See the LaTeX output
// example above for explanations.
void print_power_as_myformat(const power & p,
                             const print_myformat & c,
                             unsigned level)
@{
    unsigned power_prec = p.precedence();
    if (level >= power_prec)
        c.s << '(';
    p.op(0).print(c, power_prec);
    c.s << "**";
    p.op(1).print(c, power_prec);
    if (level >= power_prec)
        c.s << ')';
@}

@{
    ...
    // install a new print method for power objects
    set_print_func<power, print_myformat>(print_power_as_myformat);

    // now this prints "1+x**2"
    e.print(print_myformat()); cout << endl;

    // but the default format is still "1+x^2"
    cout << e << endl;
@}
@end example


@node Structures, Adding classes, Printing, Extending GiNaC
@c    node-name, next, previous, up
@section Structures

If you are doing some very specialized things with GiNaC, or if you just
need some more organized way to store data in your expressions instead of
anonymous lists, you may want to implement your own algebraic classes.
('algebraic class' means any class directly or indirectly derived from
@code{basic} that can be used in GiNaC expressions).

GiNaC offers two ways of accomplishing this: either by using the
@code{structure<T>} template class, or by rolling your own class from
scratch. This section will discuss the @code{structure<T>} template which
is easier to use but more limited, while the implementation of custom
GiNaC classes is the topic of the next section. However, you may want to
read both sections because many common concepts and member functions are
shared by both concepts, and it will also allow you to decide which approach
is most suited to your needs.

The @code{structure<T>} template, defined in the GiNaC header file
@file{structure.h}, wraps a type that you supply (usually a C++ @code{struct}
or @code{class}) into a GiNaC object that can be used in expressions.

@subsection Example: scalar products

Let's suppose that we need a way to handle some kind of abstract scalar
product of the form @samp{<x|y>} in expressions. Objects of the scalar
product class have to store their left and right operands, which can in turn
be arbitrary expressions. Here is a possible way to represent such a
product in a C++ @code{struct}:

@example
#include <iostream>
using namespace std;

#include <ginac/ginac.h>
using namespace GiNaC;

struct sprod_s @{
    ex left, right;

    sprod_s() @{@}
    sprod_s(ex l, ex r) : left(l), right(r) @{@}
@};
@end example

The default constructor is required. Now, to make a GiNaC class out of this
data structure, we need only one line:

@example
typedef structure<sprod_s> sprod;
@end example

That's it. This line constructs an algebraic class @code{sprod} which
contains objects of type @code{sprod_s}. We can now use @code{sprod} in
expressions like any other GiNaC class:

@example
...
    symbol a("a"), b("b");
    ex e = sprod(sprod_s(a, b));
...
@end example

Note the difference between @code{sprod} which is the algebraic class, and
@code{sprod_s} which is the unadorned C++ structure containing the @code{left}
and @code{right} data members. As shown above, an @code{sprod} can be
constructed from an @code{sprod_s} object.

If you find the nested @code{sprod(sprod_s())} constructor too unwieldy,
you could define a little wrapper function like this:

@example
inline ex make_sprod(ex left, ex right)
@{
    return sprod(sprod_s(left, right));
@}
@end example

The @code{sprod_s} object contained in @code{sprod} can be accessed with
the GiNaC @code{ex_to<>()} function followed by the @code{->} operator or
@code{get_struct()}:

@example
...
    cout << ex_to<sprod>(e)->left << endl;
     // -> a
    cout << ex_to<sprod>(e).get_struct().right << endl;
     // -> b
...
@end example

You only have read access to the members of @code{sprod_s}.

The type definition of @code{sprod} is enough to write your own algorithms
that deal with scalar products, for example:

@example
ex swap_sprod(ex p)
@{
    if (is_a<sprod>(p)) @{
        const sprod_s & sp = ex_to<sprod>(p).get_struct();
        return make_sprod(sp.right, sp.left);
    @} else
        return p;
@}

...
    f = swap_sprod(e);
     // f is now <b|a>
...
@end example

@subsection Structure output

While the @code{sprod} type is useable it still leaves something to be
desired, most notably proper output:

@example
...
    cout << e << endl;
     // -> [structure object]
...
@end example

By default, any structure types you define will be printed as
@samp{[structure object]}. To override this you can either specialize the
template's @code{print()} member function, or specify print methods with
@code{set_print_func<>()}, as described in @ref{Printing}. Unfortunately,
it's not possible to supply class options like @code{print_func<>()} to
structures, so for a self-contained structure type you need to resort to
overriding the @code{print()} function, which is also what we will do here.

The member functions of GiNaC classes are described in more detail in the
next section, but it shouldn't be hard to figure out what's going on here:

@example
void sprod::print(const print_context & c, unsigned level) const
@{
    // tree debug output handled by superclass
    if (is_a<print_tree>(c))
        inherited::print(c, level);

    // get the contained sprod_s object
    const sprod_s & sp = get_struct();

    // print_context::s is a reference to an ostream
    c.s << "<" << sp.left << "|" << sp.right << ">";
@}
@end example

Now we can print expressions containing scalar products:

@example
...
    cout << e << endl;
     // -> <a|b>
    cout << swap_sprod(e) << endl;
     // -> <b|a>
...
@end example

@subsection Comparing structures

The @code{sprod} class defined so far still has one important drawback: all
scalar products are treated as being equal because GiNaC doesn't know how to
compare objects of type @code{sprod_s}. This can lead to some confusing
and undesired behavior:

@example
...
    cout << make_sprod(a, b) - make_sprod(a*a, b*b) << endl;
     // -> 0
    cout << make_sprod(a, b) + make_sprod(a*a, b*b) << endl;
     // -> 2*<a|b> or 2*<a^2|b^2> (which one is undefined)
...
@end example

To remedy this, we first need to define the operators @code{==} and @code{<}
for objects of type @code{sprod_s}:

@example
inline bool operator==(const sprod_s & lhs, const sprod_s & rhs)
@{
    return lhs.left.is_equal(rhs.left) && lhs.right.is_equal(rhs.right);
@}

inline bool operator<(const sprod_s & lhs, const sprod_s & rhs)
@{
    return lhs.left.compare(rhs.left) < 0 ? true : lhs.right.compare(rhs.right) < 0;
@}
@end example

The ordering established by the @code{<} operator doesn't have to make any
algebraic sense, but it needs to be well defined. Note that we can't use
expressions like @code{lhs.left == rhs.left} or @code{lhs.left < rhs.left}
in the implementation of these operators because they would construct
GiNaC @code{relational} objects which in the case of @code{<} do not
establish a well defined ordering (for arbitrary expressions, GiNaC can't
decide which one is algebraically 'less').

Next, we need to change our definition of the @code{sprod} type to let
GiNaC know that an ordering relation exists for the embedded objects:

@example
typedef structure<sprod_s, compare_std_less> sprod;
@end example

@code{sprod} objects then behave as expected:

@example
...
    cout << make_sprod(a, b) - make_sprod(a*a, b*b) << endl;
     // -> <a|b>-<a^2|b^2>
    cout << make_sprod(a, b) + make_sprod(a*a, b*b) << endl;
     // -> <a|b>+<a^2|b^2>
    cout << make_sprod(a, b) - make_sprod(a, b) << endl;
     // -> 0
    cout << make_sprod(a, b) + make_sprod(a, b) << endl;
     // -> 2*<a|b>
...
@end example

The @code{compare_std_less} policy parameter tells GiNaC to use the
@code{std::less} and @code{std::equal_to} functors to compare objects of
type @code{sprod_s}. By default, these functors forward their work to the
standard @code{<} and @code{==} operators, which we have overloaded.
Alternatively, we could have specialized @code{std::less} and
@code{std::equal_to} for class @code{sprod_s}.

GiNaC provides two other comparison policies for @code{structure<T>}
objects: the default @code{compare_all_equal}, and @code{compare_bitwise}
which does a bit-wise comparison of the contained @code{T} objects.
This should be used with extreme care because it only works reliably with
built-in integral types, and it also compares any padding (filler bytes of
undefined value) that the @code{T} class might have.

@subsection Subexpressions

Our scalar product class has two subexpressions: the left and right
operands. It might be a good idea to make them accessible via the standard
@code{nops()} and @code{op()} methods:

@example
size_t sprod::nops() const
@{
    return 2;
@}

ex sprod::op(size_t i) const
@{
    switch (i) @{
    case 0:
        return get_struct().left;
    case 1:
        return get_struct().right;
    default:
        throw std::range_error("sprod::op(): no such operand");
    @}
@}
@end example

Implementing @code{nops()} and @code{op()} for container types such as
@code{sprod} has two other nice side effects:

@itemize @bullet
@item
@code{has()} works as expected
@item
GiNaC generates better hash keys for the objects (the default implementation
of @code{calchash()} takes subexpressions into account)
@end itemize

@cindex @code{let_op()}
There is a non-const variant of @code{op()} called @code{let_op()} that
allows replacing subexpressions:

@example
ex & sprod::let_op(size_t i)
@{
    // every non-const member function must call this
    ensure_if_modifiable();

    switch (i) @{
    case 0:
        return get_struct().left;
    case 1:
        return get_struct().right;
    default:
        throw std::range_error("sprod::let_op(): no such operand");
    @}
@}
@end example

Once we have provided @code{let_op()} we also get @code{subs()} and
@code{map()} for free. In fact, every container class that returns a non-null
@code{nops()} value must either implement @code{let_op()} or provide custom
implementations of @code{subs()} and @code{map()}.

In turn, the availability of @code{map()} enables the recursive behavior of a
couple of other default method implementations, in particular @code{evalf()},
@code{evalm()}, @code{normal()}, @code{diff()} and @code{expand()}. Although
we probably want to provide our own version of @code{expand()} for scalar
products that turns expressions like @samp{<a+b|c>} into @samp{<a|c>+<b|c>}.
This is left as an exercise for the reader.

The @code{structure<T>} template defines many more member functions that
you can override by specialization to customize the behavior of your
structures. You are referred to the next section for a description of
some of these (especially @code{eval()}). There is, however, one topic
that shall be addressed here, as it demonstrates one peculiarity of the
@code{structure<T>} template: archiving.

@subsection Archiving structures

If you don't know how the archiving of GiNaC objects is implemented, you
should first read the next section and then come back here. You're back?
Good.

To implement archiving for structures it is not enough to provide
specializations for the @code{archive()} member function and the
unarchiving constructor (the @code{unarchive()} function has a default
implementation). You also need to provide a unique name (as a string literal)
for each structure type you define. This is because in GiNaC archives,
the class of an object is stored as a string, the class name.

By default, this class name (as returned by the @code{class_name()} member
function) is @samp{structure} for all structure classes. This works as long
as you have only defined one structure type, but if you use two or more you
need to provide a different name for each by specializing the
@code{get_class_name()} member function. Here is a sample implementation
for enabling archiving of the scalar product type defined above:

@example
const char *sprod::get_class_name() @{ return "sprod"; @}

void sprod::archive(archive_node & n) const
@{
    inherited::archive(n);
    n.add_ex("left", get_struct().left);
    n.add_ex("right", get_struct().right);
@}

sprod::structure(const archive_node & n, lst & sym_lst) : inherited(n, sym_lst)
@{
    n.find_ex("left", get_struct().left, sym_lst);
    n.find_ex("right", get_struct().right, sym_lst);
@}
@end example

Note that the unarchiving constructor is @code{sprod::structure} and not
@code{sprod::sprod}, and that we don't need to supply an
@code{sprod::unarchive()} function.


@node Adding classes, A Comparison With Other CAS, Structures, Extending GiNaC
@c    node-name, next, previous, up
@section Adding classes

The @code{structure<T>} template provides an way to extend GiNaC with custom
algebraic classes that is easy to use but has its limitations, the most
severe of which being that you can't add any new member functions to
structures. To be able to do this, you need to write a new class definition
from scratch.

This section will explain how to implement new algebraic classes in GiNaC by
giving the example of a simple 'string' class. After reading this section
you will know how to properly declare a GiNaC class and what the minimum
required member functions are that you have to implement. We only cover the
implementation of a 'leaf' class here (i.e. one that doesn't contain
subexpressions). Creating a container class like, for example, a class
representing tensor products is more involved but this section should give
you enough information so you can consult the source to GiNaC's predefined
classes if you want to implement something more complicated.

@subsection GiNaC's run-time type information system

@cindex hierarchy of classes
@cindex RTTI
All algebraic classes (that is, all classes that can appear in expressions)
in GiNaC are direct or indirect subclasses of the class @code{basic}. So a
@code{basic *} (which is essentially what an @code{ex} is) represents a
generic pointer to an algebraic class. Occasionally it is necessary to find
out what the class of an object pointed to by a @code{basic *} really is.
Also, for the unarchiving of expressions it must be possible to find the
@code{unarchive()} function of a class given the class name (as a string). A
system that provides this kind of information is called a run-time type
information (RTTI) system. The C++ language provides such a thing (see the
standard header file @file{<typeinfo>}) but for efficiency reasons GiNaC
implements its own, simpler RTTI.

The RTTI in GiNaC is based on two mechanisms:

@itemize @bullet

@item
The @code{basic} class declares a member variable @code{tinfo_key} which
holds an unsigned integer that identifies the object's class. These numbers
are defined in the @file{tinfos.h} header file for the built-in GiNaC
classes. They all start with @code{TINFO_}.

@item
By means of some clever tricks with static members, GiNaC maintains a list
of information for all classes derived from @code{basic}. The information
available includes the class names, the @code{tinfo_key}s, and pointers
to the unarchiving functions. This class registry is defined in the
@file{registrar.h} header file.

@end itemize

The disadvantage of this proprietary RTTI implementation is that there's
a little more to do when implementing new classes (C++'s RTTI works more
or less automatically) but don't worry, most of the work is simplified by
macros.

@subsection A minimalistic example

Now we will start implementing a new class @code{mystring} that allows
placing character strings in algebraic expressions (this is not very useful,
but it's just an example). This class will be a direct subclass of
@code{basic}. You can use this sample implementation as a starting point
for your own classes.

The code snippets given here assume that you have included some header files
as follows:

@example
#include <iostream>
#include <string>   
#include <stdexcept>
using namespace std;

#include <ginac/ginac.h>
using namespace GiNaC;
@end example

The first thing we have to do is to define a @code{tinfo_key} for our new
class. This can be any arbitrary unsigned number that is not already taken
by one of the existing classes but it's better to come up with something
that is unlikely to clash with keys that might be added in the future. The
numbers in @file{tinfos.h} are modeled somewhat after the class hierarchy
which is not a requirement but we are going to stick with this scheme:

@example
const unsigned TINFO_mystring = 0x42420001U;
@end example

Now we can write down the class declaration. The class stores a C++
@code{string} and the user shall be able to construct a @code{mystring}
object from a C or C++ string:

@example
class mystring : public basic
@{
    GINAC_DECLARE_REGISTERED_CLASS(mystring, basic)
  
public:
    mystring(const string &s);
    mystring(const char *s);

private:
    string str;
@};

GINAC_IMPLEMENT_REGISTERED_CLASS(mystring, basic)
@end example

The @code{GINAC_DECLARE_REGISTERED_CLASS} and @code{GINAC_IMPLEMENT_REGISTERED_CLASS}
macros are defined in @file{registrar.h}. They take the name of the class
and its direct superclass as arguments and insert all required declarations
for the RTTI system. The @code{GINAC_DECLARE_REGISTERED_CLASS} should be
the first line after the opening brace of the class definition. The
@code{GINAC_IMPLEMENT_REGISTERED_CLASS} may appear anywhere else in the
source (at global scope, of course, not inside a function).

@code{GINAC_DECLARE_REGISTERED_CLASS} contains, among other things the
declarations of the default constructor and a couple of other functions that
are required. It also defines a type @code{inherited} which refers to the
superclass so you don't have to modify your code every time you shuffle around
the class hierarchy. @code{GINAC_IMPLEMENT_REGISTERED_CLASS} registers the
class with the GiNaC RTTI (there is also a
@code{GINAC_IMPLEMENT_REGISTERED_CLASS_OPT} which allows specifying additional
options for the class, and which we will be using instead in a few minutes).

Now there are seven member functions we have to implement to get a working
class:

@itemize

@item
@code{mystring()}, the default constructor.

@item
@code{void archive(archive_node &n)}, the archiving function. This stores all
information needed to reconstruct an object of this class inside an
@code{archive_node}.

@item
@code{mystring(const archive_node &n, lst &sym_lst)}, the unarchiving
constructor. This constructs an instance of the class from the information
found in an @code{archive_node}.

@item
@code{ex unarchive(const archive_node &n, lst &sym_lst)}, the static
unarchiving function. It constructs a new instance by calling the unarchiving
constructor.

@item
@cindex @code{compare_same_type()}
@code{int compare_same_type(const basic &other)}, which is used internally
by GiNaC to establish a canonical sort order for terms. It returns 0, +1 or
-1, depending on the relative order of this object and the @code{other}
object. If it returns 0, the objects are considered equal.
@strong{Note:} This has nothing to do with the (numeric) ordering
relationship expressed by @code{<}, @code{>=} etc (which cannot be defined
for non-numeric classes). For example, @code{numeric(1).compare_same_type(numeric(2))}
may return +1 even though 1 is clearly smaller than 2. Every GiNaC class
must provide a @code{compare_same_type()} function, even those representing
objects for which no reasonable algebraic ordering relationship can be
defined.

@item
And, of course, @code{mystring(const string &s)} and @code{mystring(const char *s)}
which are the two constructors we declared.

@end itemize

Let's proceed step-by-step. The default constructor looks like this:

@example
mystring::mystring() : inherited(TINFO_mystring) @{@}
@end example

The golden rule is that in all constructors you have to set the
@code{tinfo_key} member to the @code{TINFO_*} value of your class. Otherwise
it will be set by the constructor of the superclass and all hell will break
loose in the RTTI. For your convenience, the @code{basic} class provides
a constructor that takes a @code{tinfo_key} value, which we are using here
(remember that in our case @code{inherited == basic}).  If the superclass
didn't have such a constructor, we would have to set the @code{tinfo_key}
to the right value manually.

In the default constructor you should set all other member variables to
reasonable default values (we don't need that here since our @code{str}
member gets set to an empty string automatically).

Next are the three functions for archiving. You have to implement them even
if you don't plan to use archives, but the minimum required implementation
is really simple.  First, the archiving function:

@example
void mystring::archive(archive_node &n) const
@{
    inherited::archive(n);
    n.add_string("string", str);
@}
@end example

The only thing that is really required is calling the @code{archive()}
function of the superclass. Optionally, you can store all information you
deem necessary for representing the object into the passed
@code{archive_node}.  We are just storing our string here. For more
information on how the archiving works, consult the @file{archive.h} header
file.

The unarchiving constructor is basically the inverse of the archiving
function:

@example
mystring::mystring(const archive_node &n, lst &sym_lst) : inherited(n, sym_lst)
@{
    n.find_string("string", str);
@}
@end example

If you don't need archiving, just leave this function empty (but you must
invoke the unarchiving constructor of the superclass). Note that we don't
have to set the @code{tinfo_key} here because it is done automatically
by the unarchiving constructor of the @code{basic} class.

Finally, the unarchiving function:

@example
ex mystring::unarchive(const archive_node &n, lst &sym_lst)
@{
    return (new mystring(n, sym_lst))->setflag(status_flags::dynallocated);
@}
@end example

You don't have to understand how exactly this works. Just copy these
four lines into your code literally (replacing the class name, of
course).  It calls the unarchiving constructor of the class and unless
you are doing something very special (like matching @code{archive_node}s
to global objects) you don't need a different implementation. For those
who are interested: setting the @code{dynallocated} flag puts the object
under the control of GiNaC's garbage collection.  It will get deleted
automatically once it is no longer referenced.

Our @code{compare_same_type()} function uses a provided function to compare
the string members:

@example
int mystring::compare_same_type(const basic &other) const
@{
    const mystring &o = static_cast<const mystring &>(other);
    int cmpval = str.compare(o.str);
    if (cmpval == 0)
        return 0;
    else if (cmpval < 0)
        return -1;
    else
        return 1;
@}
@end example

Although this function takes a @code{basic &}, it will always be a reference
to an object of exactly the same class (objects of different classes are not
comparable), so the cast is safe. If this function returns 0, the two objects
are considered equal (in the sense that @math{A-B=0}), so you should compare
all relevant member variables.

Now the only thing missing is our two new constructors:

@example
mystring::mystring(const string &s) : inherited(TINFO_mystring), str(s) @{@}
mystring::mystring(const char *s) : inherited(TINFO_mystring), str(s) @{@}
@end example

No surprises here. We set the @code{str} member from the argument and
remember to pass the right @code{tinfo_key} to the @code{basic} constructor.

That's it! We now have a minimal working GiNaC class that can store
strings in algebraic expressions. Let's confirm that the RTTI works:

@example
ex e = mystring("Hello, world!");
cout << is_a<mystring>(e) << endl;
 // -> 1 (true)

cout << e.bp->class_name() << endl;
 // -> mystring
@end example

Obviously it does. Let's see what the expression @code{e} looks like:

@example
cout << e << endl;
 // -> [mystring object]
@end example

Hm, not exactly what we expect, but of course the @code{mystring} class
doesn't yet know how to print itself. This can be done either by implementing
the @code{print()} member function, or, preferably, by specifying a
@code{print_func<>()} class option. Let's say that we want to print the string
surrounded by double quotes:

@example
class mystring : public basic
@{
    ...
protected:
    void do_print(const print_context &c, unsigned level = 0) const;
    ...
@};

void mystring::do_print(const print_context &c, unsigned level) const
@{
    // print_context::s is a reference to an ostream
    c.s << '\"' << str << '\"';
@}
@end example

The @code{level} argument is only required for container classes to
correctly parenthesize the output.

Now we need to tell GiNaC that @code{mystring} objects should use the
@code{do_print()} member function for printing themselves. For this, we
replace the line

@example
GINAC_IMPLEMENT_REGISTERED_CLASS(mystring, basic)
@end example

with

@example
GINAC_IMPLEMENT_REGISTERED_CLASS_OPT(mystring, basic,
  print_func<print_context>(&mystring::do_print))
@end example

Let's try again to print the expression:

@example
cout << e << endl;
 // -> "Hello, world!"
@end example

Much better. If we wanted to have @code{mystring} objects displayed in a
different way depending on the output format (default, LaTeX, etc.), we
would have supplied multiple @code{print_func<>()} options with different
template parameters (@code{print_dflt}, @code{print_latex}, etc.),
separated by dots. This is similar to the way options are specified for
symbolic functions. @xref{Printing}, for a more in-depth description of the
way expression output is implemented in GiNaC.

The @code{mystring} class can be used in arbitrary expressions:

@example
e += mystring("GiNaC rulez"); 
cout << e << endl;
 // -> "GiNaC rulez"+"Hello, world!"
@end example

(GiNaC's automatic term reordering is in effect here), or even

@example
e = pow(mystring("One string"), 2*sin(Pi-mystring("Another string")));
cout << e << endl;
 // -> "One string"^(2*sin(-"Another string"+Pi))
@end example

Whether this makes sense is debatable but remember that this is only an
example. At least it allows you to implement your own symbolic algorithms
for your objects.

Note that GiNaC's algebraic rules remain unchanged:

@example
e = mystring("Wow") * mystring("Wow");
cout << e << endl;
 // -> "Wow"^2

e = pow(mystring("First")-mystring("Second"), 2);
cout << e.expand() << endl;
 // -> -2*"First"*"Second"+"First"^2+"Second"^2
@end example

There's no way to, for example, make GiNaC's @code{add} class perform string
concatenation. You would have to implement this yourself.

@subsection Automatic evaluation

@cindex evaluation
@cindex @code{eval()}
@cindex @code{hold()}
When dealing with objects that are just a little more complicated than the
simple string objects we have implemented, chances are that you will want to
have some automatic simplifications or canonicalizations performed on them.
This is done in the evaluation member function @code{eval()}. Let's say that
we wanted all strings automatically converted to lowercase with
non-alphabetic characters stripped, and empty strings removed:

@example
class mystring : public basic
@{
    ...
public:
    ex eval(int level = 0) const;
    ...
@};

ex mystring::eval(int level) const
@{
    string new_str;
    for (int i=0; i<str.length(); i++) @{
        char c = str[i];
        if (c >= 'A' && c <= 'Z') 
            new_str += tolower(c);
        else if (c >= 'a' && c <= 'z')
            new_str += c;
    @}

    if (new_str.length() == 0)
        return 0;
    else
        return mystring(new_str).hold();
@}
@end example

The @code{level} argument is used to limit the recursion depth of the
evaluation.  We don't have any subexpressions in the @code{mystring}
class so we are not concerned with this.  If we had, we would call the
@code{eval()} functions of the subexpressions with @code{level - 1} as
the argument if @code{level != 1}.  The @code{hold()} member function
sets a flag in the object that prevents further evaluation.  Otherwise
we might end up in an endless loop.  When you want to return the object
unmodified, use @code{return this->hold();}.

Let's confirm that it works:

@example
ex e = mystring("Hello, world!") + mystring("!?#");
cout << e << endl;
 // -> "helloworld"

e = mystring("Wow!") + mystring("WOW") + mystring(" W ** o ** W");  
cout << e << endl;
 // -> 3*"wow"
@end example

@subsection Optional member functions

We have implemented only a small set of member functions to make the class
work in the GiNaC framework. There are two functions that are not strictly
required but will make operations with objects of the class more efficient:

@cindex @code{calchash()}
@cindex @code{is_equal_same_type()}
@example
unsigned calchash() const;
bool is_equal_same_type(const basic &other) const;
@end example

The @code{calchash()} method returns an @code{unsigned} hash value for the
object which will allow GiNaC to compare and canonicalize expressions much
more efficiently. You should consult the implementation of some of the built-in
GiNaC classes for examples of hash functions. The default implementation of
@code{calchash()} calculates a hash value out of the @code{tinfo_key} of the
class and all subexpressions that are accessible via @code{op()}.

@code{is_equal_same_type()} works like @code{compare_same_type()} but only
tests for equality without establishing an ordering relation, which is often
faster. The default implementation of @code{is_equal_same_type()} just calls
@code{compare_same_type()} and tests its result for zero.

@subsection Other member functions

For a real algebraic class, there are probably some more functions that you
might want to provide:

@example
bool info(unsigned inf) const;
ex evalf(int level = 0) const;
ex series(const relational & r, int order, unsigned options = 0) const;
ex derivative(const symbol & s) const;
@end example

If your class stores sub-expressions (see the scalar product example in the
previous section) you will probably want to override

@cindex @code{let_op()}
@example
size_t nops() cont;
ex op(size_t i) const;
ex & let_op(size_t i);
ex subs(const lst & ls, const lst & lr, unsigned options = 0) const;
ex map(map_function & f) const;
@end example

@code{let_op()} is a variant of @code{op()} that allows write access. The
default implementations of @code{subs()} and @code{map()} use it, so you have
to implement either @code{let_op()}, or @code{subs()} and @code{map()}.

You can, of course, also add your own new member functions. Remember
that the RTTI may be used to get information about what kinds of objects
you are dealing with (the position in the class hierarchy) and that you
can always extract the bare object from an @code{ex} by stripping the
@code{ex} off using the @code{ex_to<mystring>(e)} function when that
should become a need.

That's it. May the source be with you!


@node A Comparison With Other CAS, Advantages, Adding classes, Top
@c    node-name, next, previous, up
@chapter A Comparison With Other CAS
@cindex advocacy

This chapter will give you some information on how GiNaC compares to
other, traditional Computer Algebra Systems, like @emph{Maple},
@emph{Mathematica} or @emph{Reduce}, where it has advantages and
disadvantages over these systems.

@menu
* Advantages::                       Strengths of the GiNaC approach.
* Disadvantages::                    Weaknesses of the GiNaC approach.
* Why C++?::                         Attractiveness of C++.
@end menu

@node Advantages, Disadvantages, A Comparison With Other CAS, A Comparison With Other CAS
@c    node-name, next, previous, up
@section Advantages

GiNaC has several advantages over traditional Computer
Algebra Systems, like 

@itemize @bullet

@item
familiar language: all common CAS implement their own proprietary
grammar which you have to learn first (and maybe learn again when your
vendor decides to `enhance' it).  With GiNaC you can write your program
in common C++, which is standardized.

@cindex STL
@item
structured data types: you can build up structured data types using
@code{struct}s or @code{class}es together with STL features instead of
using unnamed lists of lists of lists.

@item
strongly typed: in CAS, you usually have only one kind of variables
which can hold contents of an arbitrary type.  This 4GL like feature is
nice for novice programmers, but dangerous.
    
@item
development tools: powerful development tools exist for C++, like fancy
editors (e.g. with automatic indentation and syntax highlighting),
debuggers, visualization tools, documentation generators@dots{}

@item
modularization: C++ programs can easily be split into modules by
separating interface and implementation.

@item
price: GiNaC is distributed under the GNU Public License which means
that it is free and available with source code.  And there are excellent
C++-compilers for free, too.
    
@item
extendable: you can add your own classes to GiNaC, thus extending it on
a very low level.  Compare this to a traditional CAS that you can
usually only extend on a high level by writing in the language defined
by the parser.  In particular, it turns out to be almost impossible to
fix bugs in a traditional system.

@item
multiple interfaces: Though real GiNaC programs have to be written in
some editor, then be compiled, linked and executed, there are more ways
to work with the GiNaC engine.  Many people want to play with
expressions interactively, as in traditional CASs.  Currently, two such
windows into GiNaC have been implemented and many more are possible: the
tiny @command{ginsh} that is part of the distribution exposes GiNaC's
types to a command line and second, as a more consistent approach, an
interactive interface to the Cint C++ interpreter has been put together
(called GiNaC-cint) that allows an interactive scripting interface
consistent with the C++ language.  It is available from the usual GiNaC
FTP-site.

@item
seamless integration: it is somewhere between difficult and impossible
to call CAS functions from within a program written in C++ or any other
programming language and vice versa.  With GiNaC, your symbolic routines
are part of your program.  You can easily call third party libraries,
e.g. for numerical evaluation or graphical interaction.  All other
approaches are much more cumbersome: they range from simply ignoring the
problem (i.e. @emph{Maple}) to providing a method for `embedding' the
system (i.e. @emph{Yacas}).

@item
efficiency: often large parts of a program do not need symbolic
calculations at all.  Why use large integers for loop variables or
arbitrary precision arithmetics where @code{int} and @code{double} are
sufficient?  For pure symbolic applications, GiNaC is comparable in
speed with other CAS.

@end itemize


@node Disadvantages, Why C++?, Advantages, A Comparison With Other CAS
@c    node-name, next, previous, up
@section Disadvantages

Of course it also has some disadvantages:

@itemize @bullet

@item
advanced features: GiNaC cannot compete with a program like
@emph{Reduce} which exists for more than 30 years now or @emph{Maple}
which grows since 1981 by the work of dozens of programmers, with
respect to mathematical features.  Integration, factorization,
non-trivial simplifications, limits etc. are missing in GiNaC (and are
not planned for the near future).

@item
portability: While the GiNaC library itself is designed to avoid any
platform dependent features (it should compile on any ANSI compliant C++
compiler), the currently used version of the CLN library (fast large
integer and arbitrary precision arithmetics) can only by compiled
without hassle on systems with the C++ compiler from the GNU Compiler
Collection (GCC).@footnote{This is because CLN uses PROVIDE/REQUIRE like
macros to let the compiler gather all static initializations, which
works for GNU C++ only.  Feel free to contact the authors in case you
really believe that you need to use a different compiler.  We have
occasionally used other compilers and may be able to give you advice.}
GiNaC uses recent language features like explicit constructors, mutable
members, RTTI, @code{dynamic_cast}s and STL, so ANSI compliance is meant
literally.  Recent GCC versions starting at 2.95.3, although itself not
yet ANSI compliant, support all needed features.
    
@end itemize


@node Why C++?, Internal Structures, Disadvantages, A Comparison With Other CAS
@c    node-name, next, previous, up
@section Why C++?

Why did we choose to implement GiNaC in C++ instead of Java or any other
language?  C++ is not perfect: type checking is not strict (casting is
possible), separation between interface and implementation is not
complete, object oriented design is not enforced.  The main reason is
the often scolded feature of operator overloading in C++.  While it may
be true that operating on classes with a @code{+} operator is rarely
meaningful, it is perfectly suited for algebraic expressions.  Writing
@math{3x+5y} as @code{3*x+5*y} instead of
@code{x.times(3).plus(y.times(5))} looks much more natural.
Furthermore, the main developers are more familiar with C++ than with
any other programming language.


@node Internal Structures, Expressions are reference counted, Why C++? , Top
@c    node-name, next, previous, up
@appendix Internal Structures

@menu
* Expressions are reference counted::
* Internal representation of products and sums::
@end menu

@node Expressions are reference counted, Internal representation of products and sums, Internal Structures, Internal Structures
@c    node-name, next, previous, up
@appendixsection Expressions are reference counted

@cindex reference counting
@cindex copy-on-write
@cindex garbage collection
In GiNaC, there is an @emph{intrusive reference-counting} mechanism at work
where the counter belongs to the algebraic objects derived from class
@code{basic} but is maintained by the smart pointer class @code{ptr}, of
which @code{ex} contains an instance. If you understood that, you can safely
skip the rest of this passage.

Expressions are extremely light-weight since internally they work like
handles to the actual representation.  They really hold nothing more
than a pointer to some other object.  What this means in practice is
that whenever you create two @code{ex} and set the second equal to the
first no copying process is involved. Instead, the copying takes place
as soon as you try to change the second.  Consider the simple sequence
of code:

@example
#include <iostream>
#include <ginac/ginac.h>
using namespace std;
using namespace GiNaC;

int main()
@{
    symbol x("x"), y("y"), z("z");
    ex e1, e2;

    e1 = sin(x + 2*y) + 3*z + 41;
    e2 = e1;                // e2 points to same object as e1
    cout << e2 << endl;     // prints sin(x+2*y)+3*z+41
    e2 += 1;                // e2 is copied into a new object
    cout << e2 << endl;     // prints sin(x+2*y)+3*z+42
@}
@end example

The line @code{e2 = e1;} creates a second expression pointing to the
object held already by @code{e1}.  The time involved for this operation
is therefore constant, no matter how large @code{e1} was.  Actual
copying, however, must take place in the line @code{e2 += 1;} because
@code{e1} and @code{e2} are not handles for the same object any more.
This concept is called @dfn{copy-on-write semantics}.  It increases
performance considerably whenever one object occurs multiple times and
represents a simple garbage collection scheme because when an @code{ex}
runs out of scope its destructor checks whether other expressions handle
the object it points to too and deletes the object from memory if that
turns out not to be the case.  A slightly less trivial example of
differentiation using the chain-rule should make clear how powerful this
can be:

@example
@{
    symbol x("x"), y("y");

    ex e1 = x + 3*y;
    ex e2 = pow(e1, 3);
    ex e3 = diff(sin(e2), x);   // first derivative of sin(e2) by x
    cout << e1 << endl          // prints x+3*y
         << e2 << endl          // prints (x+3*y)^3
         << e3 << endl;         // prints 3*(x+3*y)^2*cos((x+3*y)^3)
@}
@end example

Here, @code{e1} will actually be referenced three times while @code{e2}
will be referenced two times.  When the power of an expression is built,
that expression needs not be copied.  Likewise, since the derivative of
a power of an expression can be easily expressed in terms of that
expression, no copying of @code{e1} is involved when @code{e3} is
constructed.  So, when @code{e3} is constructed it will print as
@code{3*(x+3*y)^2*cos((x+3*y)^3)} but the argument of @code{cos()} only
holds a reference to @code{e2} and the factor in front is just
@code{3*e1^2}.

As a user of GiNaC, you cannot see this mechanism of copy-on-write
semantics.  When you insert an expression into a second expression, the
result behaves exactly as if the contents of the first expression were
inserted.  But it may be useful to remember that this is not what
happens.  Knowing this will enable you to write much more efficient
code.  If you still have an uncertain feeling with copy-on-write
semantics, we recommend you have a look at the
@uref{http://www.parashift.com/c++-faq-lite/, C++-FAQ lite} by
Marshall Cline.  Chapter 16 covers this issue and presents an
implementation which is pretty close to the one in GiNaC.


@node Internal representation of products and sums, Package Tools, Expressions are reference counted, Internal Structures
@c    node-name, next, previous, up
@appendixsection Internal representation of products and sums

@cindex representation
@cindex @code{add}
@cindex @code{mul}
@cindex @code{power}
Although it should be completely transparent for the user of
GiNaC a short discussion of this topic helps to understand the sources
and also explain performance to a large degree.  Consider the 
unexpanded symbolic expression 
@tex
$2d^3 \left( 4a + 5b - 3 \right)$
@end tex
@ifnottex
@math{2*d^3*(4*a+5*b-3)}
@end ifnottex
which could naively be represented by a tree of linear containers for
addition and multiplication, one container for exponentiation with base
and exponent and some atomic leaves of symbols and numbers in this
fashion:

@image{repnaive}

@cindex pair-wise representation
However, doing so results in a rather deeply nested tree which will
quickly become inefficient to manipulate.  We can improve on this by
representing the sum as a sequence of terms, each one being a pair of a
purely numeric multiplicative coefficient and its rest.  In the same
spirit we can store the multiplication as a sequence of terms, each
having a numeric exponent and a possibly complicated base, the tree
becomes much more flat:

@image{reppair}

The number @code{3} above the symbol @code{d} shows that @code{mul}
objects are treated similarly where the coefficients are interpreted as
@emph{exponents} now.  Addition of sums of terms or multiplication of
products with numerical exponents can be coded to be very efficient with
such a pair-wise representation.  Internally, this handling is performed
by most CAS in this way.  It typically speeds up manipulations by an
order of magnitude.  The overall multiplicative factor @code{2} and the
additive term @code{-3} look somewhat out of place in this
representation, however, since they are still carrying a trivial
exponent and multiplicative factor @code{1} respectively.  Within GiNaC,
this is avoided by adding a field that carries an overall numeric
coefficient.  This results in the realistic picture of internal
representation for
@tex
$2d^3 \left( 4a + 5b - 3 \right)$:
@end tex
@ifnottex
@math{2*d^3*(4*a+5*b-3)}:
@end ifnottex

@image{repreal}

@cindex radical
This also allows for a better handling of numeric radicals, since
@code{sqrt(2)} can now be carried along calculations.  Now it should be
clear, why both classes @code{add} and @code{mul} are derived from the
same abstract class: the data representation is the same, only the
semantics differs.  In the class hierarchy, methods for polynomial
expansion and the like are reimplemented for @code{add} and @code{mul},
but the data structure is inherited from @code{expairseq}.


@node Package Tools, ginac-config, Internal representation of products and sums, Top
@c    node-name, next, previous, up
@appendix Package Tools

If you are creating a software package that uses the GiNaC library,
setting the correct command line options for the compiler and linker
can be difficult. GiNaC includes two tools to make this process easier.

@menu
* ginac-config::   A shell script to detect compiler and linker flags.
* AM_PATH_GINAC::  Macro for GNU automake.
@end menu


@node ginac-config, AM_PATH_GINAC, Package Tools, Package Tools
@c    node-name, next, previous, up
@section @command{ginac-config}
@cindex ginac-config

@command{ginac-config} is a shell script that you can use to determine
the compiler and linker command line options required to compile and
link a program with the GiNaC library.

@command{ginac-config} takes the following flags:

@table @samp
@item --version
Prints out the version of GiNaC installed.
@item --cppflags
Prints '-I' flags pointing to the installed header files.
@item --libs
Prints out the linker flags necessary to link a program against GiNaC.
@item --prefix[=@var{PREFIX}]
If @var{PREFIX} is specified, overrides the configured value of @env{$prefix}.
(And of exec-prefix, unless @code{--exec-prefix} is also specified)
Otherwise, prints out the configured value of @env{$prefix}.
@item --exec-prefix[=@var{PREFIX}]
If @var{PREFIX} is specified, overrides the configured value of @env{$exec_prefix}.
Otherwise, prints out the configured value of @env{$exec_prefix}.
@end table

Typically, @command{ginac-config} will be used within a configure
script, as described below. It, however, can also be used directly from
the command line using backquotes to compile a simple program. For
example:

@example
c++ -o simple `ginac-config --cppflags` simple.cpp `ginac-config --libs`
@end example

This command line might expand to (for example):

@example
cc -o simple -I/usr/local/include simple.cpp -L/usr/local/lib \
  -lginac -lcln -lstdc++
@end example

Not only is the form using @command{ginac-config} easier to type, it will
work on any system, no matter how GiNaC was configured.


@node AM_PATH_GINAC, Configure script options, ginac-config, Package Tools
@c    node-name, next, previous, up
@section @samp{AM_PATH_GINAC}
@cindex AM_PATH_GINAC

For packages configured using GNU automake, GiNaC also provides
a macro to automate the process of checking for GiNaC.

@example
AM_PATH_GINAC([@var{MINIMUM-VERSION}, [@var{ACTION-IF-FOUND} [, @var{ACTION-IF-NOT-FOUND}]]])
@end example

This macro:

@itemize @bullet

@item
Determines the location of GiNaC using @command{ginac-config}, which is
either found in the user's path, or from the environment variable
@env{GINACLIB_CONFIG}.

@item
Tests the installed libraries to make sure that their version
is later than @var{MINIMUM-VERSION}. (A default version will be used
if not specified)

@item
If the required version was found, sets the @env{GINACLIB_CPPFLAGS} variable
to the output of @command{ginac-config --cppflags} and the @env{GINACLIB_LIBS}
variable to the output of @command{ginac-config --libs}, and calls
@samp{AC_SUBST()} for these variables so they can be used in generated
makefiles, and then executes @var{ACTION-IF-FOUND}.

@item
If the required version was not found, sets @env{GINACLIB_CPPFLAGS} and
@env{GINACLIB_LIBS} to empty strings, and executes @var{ACTION-IF-NOT-FOUND}.

@end itemize

This macro is in file @file{ginac.m4} which is installed in
@file{$datadir/aclocal}. Note that if automake was installed with a
different @samp{--prefix} than GiNaC, you will either have to manually
move @file{ginac.m4} to automake's @file{$datadir/aclocal}, or give
aclocal the @samp{-I} option when running it.

@menu
* Configure script options::  Configuring a package that uses AM_PATH_GINAC.
* Example package::           Example of a package using AM_PATH_GINAC.
@end menu


@node Configure script options, Example package, AM_PATH_GINAC, AM_PATH_GINAC
@c    node-name, next, previous, up
@subsection Configuring a package that uses @samp{AM_PATH_GINAC}

Simply make sure that @command{ginac-config} is in your path, and run
the configure script.

Notes:

@itemize @bullet

@item
The directory where the GiNaC libraries are installed needs
to be found by your system's dynamic linker.
  
This is generally done by

@display
editing @file{/etc/ld.so.conf} and running @command{ldconfig}
@end display

or by
   
@display
setting the environment variable @env{LD_LIBRARY_PATH},
@end display

or, as a last resort, 
 
@display
giving a @samp{-R} or @samp{-rpath} flag (depending on your linker) when
running configure, for instance:

@example
LDFLAGS=-R/home/cbauer/lib ./configure
@end example
@end display

@item
You can also specify a @command{ginac-config} not in your path by
setting the @env{GINACLIB_CONFIG} environment variable to the
name of the executable

@item
If you move the GiNaC package from its installed location,
you will either need to modify @command{ginac-config} script
manually to point to the new location or rebuild GiNaC.

@end itemize

Advanced note:

@itemize @bullet
@item
configure flags
  
@example
--with-ginac-prefix=@var{PREFIX}
--with-ginac-exec-prefix=@var{PREFIX}
@end example

are provided to override the prefix and exec-prefix that were stored
in the @command{ginac-config} shell script by GiNaC's configure. You are
generally better off configuring GiNaC with the right path to begin with.
@end itemize


@node Example package, Bibliography, Configure script options, AM_PATH_GINAC
@c    node-name, next, previous, up
@subsection Example of a package using @samp{AM_PATH_GINAC}

The following shows how to build a simple package using automake
and the @samp{AM_PATH_GINAC} macro. The program used here is @file{simple.cpp}:

@example
#include <iostream>
#include <ginac/ginac.h>

int main()
@{
    GiNaC::symbol x("x");
    GiNaC::ex a = GiNaC::sin(x);
    std::cout << "Derivative of " << a 
              << " is " << a.diff(x) << std::endl;
    return 0;
@}
@end example

You should first read the introductory portions of the automake
Manual, if you are not already familiar with it.

Two files are needed, @file{configure.in}, which is used to build the
configure script:

@example
dnl Process this file with autoconf to produce a configure script.
AC_INIT(simple.cpp)
AM_INIT_AUTOMAKE(simple.cpp, 1.0.0)

AC_PROG_CXX
AC_PROG_INSTALL
AC_LANG_CPLUSPLUS

AM_PATH_GINAC(0.9.0, [
  LIBS="$LIBS $GINACLIB_LIBS"
  CPPFLAGS="$CPPFLAGS $GINACLIB_CPPFLAGS"  
], AC_MSG_ERROR([need to have GiNaC installed]))

AC_OUTPUT(Makefile)
@end example

The only command in this which is not standard for automake
is the @samp{AM_PATH_GINAC} macro.

That command does the following: If a GiNaC version greater or equal
than 0.7.0 is found, then it adds @env{$GINACLIB_LIBS} to @env{$LIBS}
and @env{$GINACLIB_CPPFLAGS} to @env{$CPPFLAGS}. Otherwise, it dies with
the error message `need to have GiNaC installed'

And the @file{Makefile.am}, which will be used to build the Makefile.

@example
## Process this file with automake to produce Makefile.in
bin_PROGRAMS = simple
simple_SOURCES = simple.cpp
@end example

This @file{Makefile.am}, says that we are building a single executable,
from a single source file @file{simple.cpp}. Since every program
we are building uses GiNaC we simply added the GiNaC options
to @env{$LIBS} and @env{$CPPFLAGS}, but in other circumstances, we might
want to specify them on a per-program basis: for instance by
adding the lines:

@example
simple_LDADD = $(GINACLIB_LIBS)
INCLUDES = $(GINACLIB_CPPFLAGS)
@end example

to the @file{Makefile.am}.

To try this example out, create a new directory and add the three
files above to it.

Now execute the following commands:

@example
$ automake --add-missing
$ aclocal
$ autoconf
@end example

You now have a package that can be built in the normal fashion

@example
$ ./configure
$ make
$ make install
@end example


@node Bibliography, Concept Index, Example package, Top
@c    node-name, next, previous, up
@appendix Bibliography

@itemize @minus{}

@item
@cite{ISO/IEC 14882:1998: Programming Languages: C++}

@item
@cite{CLN: A Class Library for Numbers}, @email{haible@@ilog.fr, Bruno Haible}

@item
@cite{The C++ Programming Language}, Bjarne Stroustrup, 3rd Edition, ISBN 0-201-88954-4, Addison Wesley

@item
@cite{C++ FAQs}, Marshall Cline, ISBN 0-201-58958-3, 1995, Addison Wesley

@item
@cite{Algorithms for Computer Algebra}, Keith O. Geddes, Stephen R. Czapor,
and George Labahn, ISBN 0-7923-9259-0, 1992, Kluwer Academic Publishers, Norwell, Massachusetts

@item
@cite{Computer Algebra: Systems and Algorithms for Algebraic Computation},
James H. Davenport, Yvon Siret and Evelyne Tournier, ISBN 0-12-204230-1, 1988, 
Academic Press, London

@item
@cite{Computer Algebra Systems - A Practical Guide},
Michael J. Wester (editor), ISBN 0-471-98353-5, 1999, Wiley, Chichester

@item
@cite{The Art of Computer Programming, Vol 2: Seminumerical Algorithms},
Donald E. Knuth, ISBN 0-201-89684-2, 1998, Addison Wesley

@item
@cite{Pi Unleashed}, J@"org Arndt and Christoph Haenel,
ISBN 3-540-66572-2, 2001, Springer, Heidelberg

@item
@cite{The Role of gamma5 in Dimensional Regularization}, Dirk Kreimer, hep-ph/9401354

@end itemize


@node Concept Index, , Bibliography, Top
@c    node-name, next, previous, up
@unnumbered Concept Index

@printindex cp

@bye
